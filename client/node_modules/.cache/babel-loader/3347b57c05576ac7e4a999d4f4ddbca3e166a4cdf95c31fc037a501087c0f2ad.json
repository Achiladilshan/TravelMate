{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * A limited-capacity map with a least-recently-used eviction policy. Includes\n * the operations `get`, `set`, and `has`, which behave the same as on a `Map`.\n */\nexport class LRUMap {\n  /**\n   * @param capacity - The maximum number of entries allowed in the map. When\n   *     inserting a new entry beyond this limit, the least recently used entry\n   *     will be evicted.\n   */\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.map = new Map();\n  }\n  has(key) {\n    this.reinsertIfPresent(key);\n    return this.map.has(key);\n  }\n  get(key) {\n    this.reinsertIfPresent(key);\n    return this.map.get(key);\n  }\n  set(key, value) {\n    // Rather than reinserting the entry, just delete it to avoid the extra call\n    // to this.map.set().\n    this.delete(key);\n    this.map.set(key, value);\n    if (this.map.size > this.capacity) {\n      const [lruKey] = this.map.keys();\n      this.map.delete(lruKey);\n    }\n  }\n  delete(key) {\n    if (this.map.has(key)) {\n      this.map.delete(key);\n    }\n  }\n  /**\n   * Reinserts the entry with the given key if it exists. This is used to\n   * implement the LRU policy: the native `Map` is ordered by insertion order,\n   * so the reinsertion keeps it ordered by access time.\n   */\n  reinsertIfPresent(key) {\n    if (this.map.has(key)) {\n      const value = this.map.get(key);\n      this.map.delete(key);\n      this.map.set(key, value);\n    }\n  }\n}","map":{"version":3,"names":["LRUMap","constructor","capacity","map","Map","has","key","reinsertIfPresent","get","set","value","delete","size","lruKey","keys"],"sources":["/Users/achiladilshan/Desktop/travelmate/client/node_modules/@googlemaps/extended-component-library/src/utils/lru_map.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * A limited-capacity map with a least-recently-used eviction policy. Includes\n * the operations `get`, `set`, and `has`, which behave the same as on a `Map`.\n */\nexport class LRUMap<K, V> {\n  private readonly map = new Map<K, V>();\n\n  /**\n   * @param capacity - The maximum number of entries allowed in the map. When\n   *     inserting a new entry beyond this limit, the least recently used entry\n   *     will be evicted.\n   */\n  constructor(private readonly capacity: number) {}\n\n  has(key: K): boolean {\n    this.reinsertIfPresent(key);\n    return this.map.has(key);\n  }\n\n  get(key: K): V|undefined {\n    this.reinsertIfPresent(key);\n    return this.map.get(key);\n  }\n\n  set(key: K, value: V) {\n    // Rather than reinserting the entry, just delete it to avoid the extra call\n    // to this.map.set().\n    this.delete(key);\n    this.map.set(key, value);\n    if (this.map.size > this.capacity) {\n      const [lruKey] = this.map.keys();\n      this.map.delete(lruKey);\n    }\n  }\n\n  delete(key: K) {\n    if (this.map.has(key)) {\n      this.map.delete(key);\n    }\n  }\n\n  /**\n   * Reinserts the entry with the given key if it exists. This is used to\n   * implement the LRU policy: the native `Map` is ordered by insertion order,\n   * so the reinsertion keeps it ordered by access time.\n   */\n  private reinsertIfPresent(key: K) {\n    if (this.map.has(key)) {\n      const value = this.map.get(key)!;\n      this.map.delete(key);\n      this.map.set(key, value);\n    }\n  }\n}\n"],"mappings":"AAAA;;;;;AAMA;;;;AAIA,OAAM,MAAOA,MAAM;EAGjB;;;;;EAKAC,YAA6BC,QAAgB;IAAhB,KAAAA,QAAQ,GAARA,QAAQ;IAPpB,KAAAC,GAAG,GAAG,IAAIC,GAAG,EAAQ;EAOU;EAEhDC,GAAGA,CAACC,GAAM;IACR,IAAI,CAACC,iBAAiB,CAACD,GAAG,CAAC;IAC3B,OAAO,IAAI,CAACH,GAAG,CAACE,GAAG,CAACC,GAAG,CAAC;EAC1B;EAEAE,GAAGA,CAACF,GAAM;IACR,IAAI,CAACC,iBAAiB,CAACD,GAAG,CAAC;IAC3B,OAAO,IAAI,CAACH,GAAG,CAACK,GAAG,CAACF,GAAG,CAAC;EAC1B;EAEAG,GAAGA,CAACH,GAAM,EAAEI,KAAQ;IAClB;IACA;IACA,IAAI,CAACC,MAAM,CAACL,GAAG,CAAC;IAChB,IAAI,CAACH,GAAG,CAACM,GAAG,CAACH,GAAG,EAAEI,KAAK,CAAC;IACxB,IAAI,IAAI,CAACP,GAAG,CAACS,IAAI,GAAG,IAAI,CAACV,QAAQ,EAAE;MACjC,MAAM,CAACW,MAAM,CAAC,GAAG,IAAI,CAACV,GAAG,CAACW,IAAI,EAAE;MAChC,IAAI,CAACX,GAAG,CAACQ,MAAM,CAACE,MAAM,CAAC;;EAE3B;EAEAF,MAAMA,CAACL,GAAM;IACX,IAAI,IAAI,CAACH,GAAG,CAACE,GAAG,CAACC,GAAG,CAAC,EAAE;MACrB,IAAI,CAACH,GAAG,CAACQ,MAAM,CAACL,GAAG,CAAC;;EAExB;EAEA;;;;;EAKQC,iBAAiBA,CAACD,GAAM;IAC9B,IAAI,IAAI,CAACH,GAAG,CAACE,GAAG,CAACC,GAAG,CAAC,EAAE;MACrB,MAAMI,KAAK,GAAG,IAAI,CAACP,GAAG,CAACK,GAAG,CAACF,GAAG,CAAE;MAChC,IAAI,CAACH,GAAG,CAACQ,MAAM,CAACL,GAAG,CAAC;MACpB,IAAI,CAACH,GAAG,CAACM,GAAG,CAACH,GAAG,EAAEI,KAAK,CAAC;;EAE5B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}