{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate, __metadata } from \"tslib\";\nimport { provide } from '@lit/context';\nimport { customElement, property } from 'lit/decorators.js';\nimport { BaseComponent } from '../../base/base_component.js';\nimport { DirectionsController } from '../../place_building_blocks/place_distance_label/directions_controller.js';\nimport { LAT_LNG_LITERAL_ATTRIBUTE_CONVERTER } from '../../utils/attribute_converters.js';\nimport { routeContext } from '../route_data_consumer.js';\n/**\n * Provides route data to child components as context.\n *\n * This component can fetch route data from the Directions API, or forward a\n * `DirectionsRoute` object provided from elsewhere in code. The component will\n * locally cache route data to avoid redundant API requests.\n *\n * @slot - Elements to receive route data.\n *\n * @event {RequestErrorEvent} gmpx-requesterror - Indicates an error condition\n * in an underlying Google Maps JavaScript API call. (React: onRequestError)\n */\nlet RouteDataProvider = class RouteDataProvider extends BaseComponent {\n  constructor() {\n    super(...arguments);\n    /**\n     * The travel mode of the directions request.\n     */\n    this.travelMode = 'driving';\n    this.directionsController = new DirectionsController(this);\n  }\n  updated() {\n    this.updateContextRoute();\n  }\n  async updateContextRoute() {\n    if (this.route) {\n      this.contextRoute = this.route;\n      return;\n    }\n    const numOrigins = numTruthy(this.originAddress, this.originPlaceId, this.originLatLng);\n    const numDestinations = numTruthy(this.destinationAddress, this.destinationPlaceId, this.destinationLatLng);\n    if (numOrigins === 1 && numDestinations === 1) {\n      this.contextRoute = await this.fetchRoute();\n    } else {\n      if (numOrigins > 1 && numDestinations !== 0) {\n        this.logger.error('Too many origins. Only one of origin-lat-lng, ' + 'origin-place-id, or origin-address may be specified.');\n      }\n      if (numDestinations > 1 && numOrigins !== 0) {\n        this.logger.error('Too many destinations. Only one of destination-lat-lng, ' + 'destination-place-id, or destination-address may be specified.');\n      }\n      this.contextRoute = undefined;\n    }\n  }\n  async fetchRoute() {\n    // If the request fails, directionsController.route will dispatch a\n    // RequestErrorEvent and return null.\n    const result = await this.directionsController.route({\n      origin: this.getOriginRequestObject(),\n      destination: this.getDestinationRequestObject(),\n      travelMode: this.travelMode?.toUpperCase()\n    });\n    return result?.routes ? result.routes[0] : undefined;\n  }\n  getOriginRequestObject() {\n    if (this.originLatLng) {\n      return {\n        location: this.originLatLng\n      };\n    } else if (this.originPlaceId) {\n      return {\n        placeId: this.originPlaceId\n      };\n    } else {\n      return {\n        query: this.originAddress\n      };\n    }\n  }\n  getDestinationRequestObject() {\n    if (this.destinationLatLng) {\n      return {\n        location: this.destinationLatLng\n      };\n    } else if (this.destinationPlaceId) {\n      return {\n        placeId: this.destinationPlaceId\n      };\n    } else {\n      return {\n        query: this.destinationAddress\n      };\n    }\n  }\n};\n__decorate([provide({\n  context: routeContext\n}), property({\n  attribute: false,\n  // The contextRoute property is only set by the component itself during its\n  // update cycle. Don't trigger a second update when this happens.\n  hasChanged: () => false\n}), __metadata(\"design:type\", Object)], RouteDataProvider.prototype, \"contextRoute\", void 0);\n__decorate([property({\n  converter: LAT_LNG_LITERAL_ATTRIBUTE_CONVERTER,\n  attribute: 'destination-lat-lng',\n  reflect: true\n}), __metadata(\"design:type\", Object)], RouteDataProvider.prototype, \"destinationLatLng\", void 0);\n__decorate([property({\n  type: String,\n  attribute: 'destination-place-id',\n  reflect: true\n}), __metadata(\"design:type\", String)], RouteDataProvider.prototype, \"destinationPlaceId\", void 0);\n__decorate([property({\n  type: String,\n  attribute: 'destination-address',\n  reflect: true\n}), __metadata(\"design:type\", String)], RouteDataProvider.prototype, \"destinationAddress\", void 0);\n__decorate([property({\n  converter: LAT_LNG_LITERAL_ATTRIBUTE_CONVERTER,\n  attribute: 'origin-lat-lng',\n  reflect: true\n}), __metadata(\"design:type\", Object)], RouteDataProvider.prototype, \"originLatLng\", void 0);\n__decorate([property({\n  type: String,\n  attribute: 'origin-place-id',\n  reflect: true\n}), __metadata(\"design:type\", String)], RouteDataProvider.prototype, \"originPlaceId\", void 0);\n__decorate([property({\n  type: String,\n  attribute: 'origin-address',\n  reflect: true\n}), __metadata(\"design:type\", String)], RouteDataProvider.prototype, \"originAddress\", void 0);\n__decorate([property({\n  attribute: false\n}), __metadata(\"design:type\", Object)], RouteDataProvider.prototype, \"route\", void 0);\n__decorate([property({\n  type: String,\n  attribute: 'travel-mode',\n  reflect: true\n}), __metadata(\"design:type\", Object)], RouteDataProvider.prototype, \"travelMode\", void 0);\nRouteDataProvider = __decorate([customElement('gmpx-route-data-provider')], RouteDataProvider);\nexport { RouteDataProvider };\n/**\n * Counts and returns the number of arguments that are truthy.\n */\nfunction numTruthy(...args) {\n  return args.filter(x => x).length;\n}","map":{"version":3,"names":["provide","customElement","property","BaseComponent","DirectionsController","LAT_LNG_LITERAL_ATTRIBUTE_CONVERTER","routeContext","RouteDataProvider","constructor","travelMode","directionsController","updated","updateContextRoute","route","contextRoute","numOrigins","numTruthy","originAddress","originPlaceId","originLatLng","numDestinations","destinationAddress","destinationPlaceId","destinationLatLng","fetchRoute","logger","error","undefined","result","origin","getOriginRequestObject","destination","getDestinationRequestObject","toUpperCase","routes","location","placeId","query","__decorate","context","attribute","hasChanged","converter","reflect","type","String","args","filter","x","length"],"sources":["/Users/achiladilshan/Desktop/travelmate/client/node_modules/@googlemaps/extended-component-library/src/route_building_blocks/route_data_provider/route_data_provider.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {provide} from '@lit/context';\nimport {customElement, property} from 'lit/decorators.js';\n\nimport {BaseComponent} from '../../base/base_component.js';\nimport {DirectionsController} from '../../place_building_blocks/place_distance_label/directions_controller.js';\nimport {LAT_LNG_LITERAL_ATTRIBUTE_CONVERTER} from '../../utils/attribute_converters.js';\nimport {routeContext} from '../route_data_consumer.js';\n\ntype DirectionsRoute = google.maps.DirectionsRoute;\ntype LatLng = google.maps.LatLng;\ntype LatLngLiteral = google.maps.LatLngLiteral;\n\n/**\n * Provides route data to child components as context.\n *\n * This component can fetch route data from the Directions API, or forward a\n * `DirectionsRoute` object provided from elsewhere in code. The component will\n * locally cache route data to avoid redundant API requests.\n *\n * @slot - Elements to receive route data.\n *\n * @event {RequestErrorEvent} gmpx-requesterror - Indicates an error condition\n * in an underlying Google Maps JavaScript API call. (React: onRequestError)\n */\n@customElement('gmpx-route-data-provider')\nexport class RouteDataProvider extends BaseComponent {\n  /**\n   * @ignore\n   * Route data passed to child `RouteDataConsumer`s via context.\n   */\n  @provide({context: routeContext})\n  @property({\n    attribute: false,\n    // The contextRoute property is only set by the component itself during its\n    // update cycle. Don't trigger a second update when this happens.\n    hasChanged: () => false,\n  })\n  contextRoute: DirectionsRoute|undefined;\n\n  /**\n   * The destination of the directions request as a lat/lng. When setting the\n   * destination, only one of lat/lng, Place ID, or address should be specified.\n   */\n  @property({\n    converter: LAT_LNG_LITERAL_ATTRIBUTE_CONVERTER,\n    attribute: 'destination-lat-lng',\n    reflect: true\n  })\n  destinationLatLng?: LatLng|LatLngLiteral;\n\n  /**\n   * The destination of the directions request as a Place ID. When setting the\n   * destination, only one of lat/lng, Place ID, or address should be specified.\n   */\n  @property({type: String, attribute: 'destination-place-id', reflect: true})\n  destinationPlaceId?: string;\n\n  /**\n   * The destination of the directions request as an address query. When setting\n   * the destination, only one of lat/lng, Place ID, or address should be\n   * specified.\n   */\n  @property({type: String, attribute: 'destination-address', reflect: true})\n  destinationAddress?: string;\n\n  /**\n   * The origin of the directions request as a lat/lng. When setting the origin,\n   * only one of lat/lng, Place ID, or address should be specified.\n   */\n  @property({\n    converter: LAT_LNG_LITERAL_ATTRIBUTE_CONVERTER,\n    attribute: 'origin-lat-lng',\n    reflect: true\n  })\n  originLatLng?: LatLng|LatLngLiteral;\n\n  /**\n   * The origin of the directions request as a Place ID. When setting the\n   * origin, only one of lat/lng, Place ID, or address should be specified.\n   */\n  @property({type: String, attribute: 'origin-place-id', reflect: true})\n  originPlaceId?: string;\n\n  /**\n   * The origin of the directions request as an address query. When setting the\n   * origin, only one of lat/lng, Place ID, or address should be specified.\n   */\n  @property({type: String, attribute: 'origin-address', reflect: true})\n  originAddress?: string;\n\n  /**\n   * Route data to be provided to consumers directly, instead of making an API\n   * call.\n   */\n  @property({attribute: false}) route?: DirectionsRoute;\n\n  /**\n   * The travel mode of the directions request.\n   */\n  @property({type: String, attribute: 'travel-mode', reflect: true})\n  travelMode: Lowercase<google.maps.TravelMode> = 'driving';\n\n  private readonly directionsController = new DirectionsController(this);\n\n  protected override updated() {\n    this.updateContextRoute();\n  }\n\n  private async updateContextRoute() {\n    if (this.route) {\n      this.contextRoute = this.route;\n      return;\n    }\n\n    const numOrigins =\n        numTruthy(this.originAddress, this.originPlaceId, this.originLatLng);\n    const numDestinations = numTruthy(\n        this.destinationAddress, this.destinationPlaceId,\n        this.destinationLatLng);\n\n    if (numOrigins === 1 && numDestinations === 1) {\n      this.contextRoute = await this.fetchRoute();\n    } else {\n      if (numOrigins > 1 && numDestinations !== 0) {\n        this.logger.error(\n            'Too many origins. Only one of origin-lat-lng, ' +\n            'origin-place-id, or origin-address may be specified.');\n      }\n      if (numDestinations > 1 && numOrigins !== 0) {\n        this.logger.error(\n            'Too many destinations. Only one of destination-lat-lng, ' +\n            'destination-place-id, or destination-address may be specified.');\n      }\n      this.contextRoute = undefined;\n    }\n  }\n\n  private async fetchRoute(): Promise<DirectionsRoute|undefined> {\n    // If the request fails, directionsController.route will dispatch a\n    // RequestErrorEvent and return null.\n    const result = await this.directionsController.route({\n      origin: this.getOriginRequestObject(),\n      destination: this.getDestinationRequestObject(),\n      travelMode: this.travelMode?.toUpperCase() as google.maps.TravelMode,\n    });\n    return result?.routes ? result.routes[0] : undefined;\n  }\n\n  private getOriginRequestObject(): google.maps.Place {\n    if (this.originLatLng) {\n      return {location: this.originLatLng};\n    } else if (this.originPlaceId) {\n      return {placeId: this.originPlaceId};\n    } else {\n      return {query: this.originAddress};\n    }\n  }\n\n  private getDestinationRequestObject(): google.maps.Place {\n    if (this.destinationLatLng) {\n      return {location: this.destinationLatLng};\n    } else if (this.destinationPlaceId) {\n      return {placeId: this.destinationPlaceId};\n    } else {\n      return {query: this.destinationAddress};\n    }\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'gmpx-route-data-provider': RouteDataProvider;\n  }\n}\n\n/**\n * Counts and returns the number of arguments that are truthy.\n */\nfunction numTruthy(...args: unknown[]): number {\n  return args.filter((x) => x).length;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}