{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Gets the active element, even if it's nested inside shadow DOMs.\n *\n * If the active element is in a shadow DOM, document.activeElement will be the\n * light DOM element whose shadow DOM contains it, so this is needed to find the\n * true active element.\n *\n * @return The active element, or `<body>` or null if there is none.\n */\nexport function getDeepActiveElement() {\n  let current = document.activeElement;\n  if (!current) return null;\n  let next;\n  while (next = current.shadowRoot?.activeElement) {\n    current = next;\n  }\n  return current;\n}\n/**\n * Generator function that yields the chain of parent nodes upwards in the DOM\n * starting at `node`, and piercing shadow boundaries.\n */\nexport function* deepParentChain(node) {\n  while (true) {\n    yield node;\n    if (node.parentNode) {\n      node = node.parentNode;\n    } else if (node instanceof ShadowRoot) {\n      node = node.host;\n    } else {\n      return;\n    }\n  }\n}\n/**\n * Behaves like Node.contains() but accounts for shadow descendants as well.\n *\n * @param rootNode - A node that might be the ancestor.\n * @param otherNode - A node that might be the descendant.\n * @return true if otherNode is a light or shadow descendant of rootNode.\n */\nexport function deepContains(rootNode, otherNode) {\n  if (!rootNode || !otherNode) return false;\n  for (const node of deepParentChain(otherNode)) {\n    if (node === rootNode) return true;\n  }\n  return false;\n}\n/**\n * Returns true if for some node in rootNodes, otherNode is a light or shadow\n * descendant of the node. Uses a single search in\n * O(|rootNodes| + (depth of otherNode)).\n */\nexport function someDeepContains(rootNodes, otherNode) {\n  if (rootNodes.length === 0 || !otherNode) return false;\n  const rootNodeSet = new Set(rootNodes);\n  for (const node of deepParentChain(otherNode)) {\n    if (rootNodeSet.has(node)) return true;\n  }\n  return false;\n}","map":{"version":3,"names":["getDeepActiveElement","current","document","activeElement","next","shadowRoot","deepParentChain","node","parentNode","ShadowRoot","host","deepContains","rootNode","otherNode","someDeepContains","rootNodes","length","rootNodeSet","Set","has"],"sources":["/Users/achiladilshan/Desktop/travelmate/client/node_modules/@googlemaps/extended-component-library/src/utils/deep_element_access.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Gets the active element, even if it's nested inside shadow DOMs.\n *\n * If the active element is in a shadow DOM, document.activeElement will be the\n * light DOM element whose shadow DOM contains it, so this is needed to find the\n * true active element.\n *\n * @return The active element, or `<body>` or null if there is none.\n */\nexport function getDeepActiveElement(): Element|null {\n  let current = document.activeElement;\n  if (!current) return null;\n  let next;\n  while ((next = current.shadowRoot?.activeElement)) {\n    current = next;\n  }\n  return current;\n}\n\n/**\n * Generator function that yields the chain of parent nodes upwards in the DOM\n * starting at `node`, and piercing shadow boundaries.\n */\nexport function* deepParentChain(node: Node) {\n  while (true) {\n    yield node;\n    if (node.parentNode) {\n      node = node.parentNode;\n    } else if (node instanceof ShadowRoot) {\n      node = node.host;\n    } else {\n      return;\n    }\n  }\n}\n\n/**\n * Behaves like Node.contains() but accounts for shadow descendants as well.\n *\n * @param rootNode - A node that might be the ancestor.\n * @param otherNode - A node that might be the descendant.\n * @return true if otherNode is a light or shadow descendant of rootNode.\n */\nexport function deepContains(\n    rootNode: Node|null|undefined, otherNode: Node|null|undefined): boolean {\n  if (!rootNode || !otherNode) return false;\n  for (const node of deepParentChain(otherNode)) {\n    if (node === rootNode) return true;\n  }\n  return false;\n}\n\n/**\n * Returns true if for some node in rootNodes, otherNode is a light or shadow\n * descendant of the node. Uses a single search in\n * O(|rootNodes| + (depth of otherNode)).\n */\nexport function someDeepContains(\n    rootNodes: Node[], otherNode: Node|null|undefined): boolean {\n  if ((rootNodes.length === 0) || !otherNode) return false;\n  const rootNodeSet = new Set(rootNodes);\n  for (const node of deepParentChain(otherNode)) {\n    if (rootNodeSet.has(node)) return true;\n  }\n  return false;\n}\n"],"mappings":"AAAA;;;;;AAMA;;;;;;;;;AASA,OAAM,SAAUA,oBAAoBA,CAAA;EAClC,IAAIC,OAAO,GAAGC,QAAQ,CAACC,aAAa;EACpC,IAAI,CAACF,OAAO,EAAE,OAAO,IAAI;EACzB,IAAIG,IAAI;EACR,OAAQA,IAAI,GAAGH,OAAO,CAACI,UAAU,EAAEF,aAAa,EAAG;IACjDF,OAAO,GAAGG,IAAI;;EAEhB,OAAOH,OAAO;AAChB;AAEA;;;;AAIA,OAAM,UAAWK,eAAeA,CAACC,IAAU;EACzC,OAAO,IAAI,EAAE;IACX,MAAMA,IAAI;IACV,IAAIA,IAAI,CAACC,UAAU,EAAE;MACnBD,IAAI,GAAGA,IAAI,CAACC,UAAU;KACvB,MAAM,IAAID,IAAI,YAAYE,UAAU,EAAE;MACrCF,IAAI,GAAGA,IAAI,CAACG,IAAI;KACjB,MAAM;MACL;;;AAGN;AAEA;;;;;;;AAOA,OAAM,SAAUC,YAAYA,CACxBC,QAA6B,EAAEC,SAA8B;EAC/D,IAAI,CAACD,QAAQ,IAAI,CAACC,SAAS,EAAE,OAAO,KAAK;EACzC,KAAK,MAAMN,IAAI,IAAID,eAAe,CAACO,SAAS,CAAC,EAAE;IAC7C,IAAIN,IAAI,KAAKK,QAAQ,EAAE,OAAO,IAAI;;EAEpC,OAAO,KAAK;AACd;AAEA;;;;;AAKA,OAAM,SAAUE,gBAAgBA,CAC5BC,SAAiB,EAAEF,SAA8B;EACnD,IAAKE,SAAS,CAACC,MAAM,KAAK,CAAC,IAAK,CAACH,SAAS,EAAE,OAAO,KAAK;EACxD,MAAMI,WAAW,GAAG,IAAIC,GAAG,CAACH,SAAS,CAAC;EACtC,KAAK,MAAMR,IAAI,IAAID,eAAe,CAACO,SAAS,CAAC,EAAE;IAC7C,IAAII,WAAW,CAACE,GAAG,CAACZ,IAAI,CAAC,EAAE,OAAO,IAAI;;EAExC,OAAO,KAAK;AACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}