{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { APILoader } from '../api_loader/api_loader.js';\nimport { RequestCache } from '../utils/request_cache.js';\nconst CACHE_SIZE = 10;\nconst MAX_DISTANCE_MATRIX_DESTINATIONS = 25;\nfunction makeDistanceMatrixRequestCache() {\n  return new RequestCache(CACHE_SIZE, error => {\n    // Requests with a transient error of OVER_QUERY_LIMIT\n    // and UNKNOWN_ERROR should be retried. See full list of statuses\n    // https://developers.google.com/maps/documentation/javascript/reference/distance-matrix#DistanceMatrixStatus\n    return error.code === 'OVER_QUERY_LIMIT' || error.code === 'UNKNOWN_ERROR';\n  });\n}\n/** How a distance was calculated. */\nexport var DistanceSource;\n(function (DistanceSource) {\n  DistanceSource[DistanceSource[\"GEOMETRIC\"] = 0] = \"GEOMETRIC\";\n  DistanceSource[DistanceSource[\"DISTANCE_MATRIX\"] = 1] = \"DISTANCE_MATRIX\";\n})(DistanceSource || (DistanceSource = {}));\n/**\n * A utility for calculating distances from a single point to N other points.\n *\n * This class combines the Maps JS Distance Matrix API with a global request\n * cache and a fallback for when N is more than allowed by the API.\n */\nexport class DistanceMeasurer {\n  constructor(elementForLogging) {\n    this.elementForLogging = elementForLogging;\n  }\n  /**\n   * Computes travel distance between `origin` and each of the `destinations`.\n   *\n   * If there are more than 25 `destinations`, the Distance Matrix API cannot\n   * process them in a single request. In this case, the method will assign\n   * a geometric distance to all N `destinations`, then use Distance Matrix\n   * to compute accurate distances to the nearest 25 options.\n   */\n  async computeDistances(origin, destinations, units) {\n    const distances = new Map();\n    for (const destination of destinations) {\n      distances.set(destination, {});\n    }\n    let destinationsForLookup = [...destinations];\n    if (destinations.length > MAX_DISTANCE_MATRIX_DESTINATIONS) {\n      // Too many `destinations` for Distance Matrix; start by calculating\n      // geometric distance.\n      const {\n        spherical\n      } = await APILoader.importLibrary('geometry', this.elementForLogging);\n      for (const [destination, distanceInfo] of distances.entries()) {\n        distanceInfo.source = DistanceSource.GEOMETRIC;\n        distanceInfo.value = spherical.computeDistanceBetween(origin, destination);\n      }\n      // Take the top 25 closest points to refine via Distance Matrix.\n      const getSphericalDistance = p => distances.get(p)?.value ?? Infinity;\n      destinationsForLookup.sort((a, b) => getSphericalDistance(a) - getSphericalDistance(b));\n      destinationsForLookup = destinationsForLookup.slice(0, MAX_DISTANCE_MATRIX_DESTINATIONS);\n    }\n    const request = {\n      origins: [origin],\n      destinations: destinationsForLookup,\n      travelMode: 'DRIVING',\n      unitSystem: units\n    };\n    let responsePromise = DistanceMeasurer.cache.get(request);\n    if (responsePromise == null) {\n      responsePromise = this.getService().then(service => service.getDistanceMatrix(request));\n      DistanceMeasurer.cache.set(request, responsePromise);\n    }\n    const response = await responsePromise;\n    for (let i = 0; i < response.rows[0].elements.length; i++) {\n      const distanceInfo = distances.get(destinationsForLookup[i]);\n      const apiResult = response.rows[0].elements[i];\n      if (apiResult.status === 'OK') {\n        distanceInfo.value = apiResult.distance.value;\n        distanceInfo.text = apiResult.distance.text;\n        distanceInfo.source = DistanceSource.DISTANCE_MATRIX;\n      }\n    }\n    return destinations.map(destination => distances.get(destination));\n  }\n  async getService() {\n    if (!DistanceMeasurer.service) {\n      const {\n        DistanceMatrixService\n      } = await APILoader.importLibrary('routes', this.elementForLogging);\n      DistanceMeasurer.service = new DistanceMatrixService();\n    }\n    return DistanceMeasurer.service;\n  }\n  /**\n   * Resets Distance Measurer state by deleting any existing service object\n   * and clearing its cache.\n   * This method should be invoked for testing purposes only.\n   * @ignore\n   */\n  static reset() {\n    DistanceMeasurer.cache = makeDistanceMatrixRequestCache();\n    DistanceMeasurer.service = undefined;\n  }\n}\nDistanceMeasurer.cache = makeDistanceMatrixRequestCache();","map":{"version":3,"names":["APILoader","RequestCache","CACHE_SIZE","MAX_DISTANCE_MATRIX_DESTINATIONS","makeDistanceMatrixRequestCache","error","code","DistanceSource","DistanceMeasurer","constructor","elementForLogging","computeDistances","origin","destinations","units","distances","Map","destination","set","destinationsForLookup","length","spherical","importLibrary","distanceInfo","entries","source","GEOMETRIC","value","computeDistanceBetween","getSphericalDistance","p","get","Infinity","sort","a","b","slice","request","origins","travelMode","unitSystem","responsePromise","cache","getService","then","service","getDistanceMatrix","response","i","rows","elements","apiResult","status","distance","text","DISTANCE_MATRIX","map","DistanceMatrixService","reset","undefined"],"sources":["/Users/achiladilshan/Desktop/travelmate/client/node_modules/@googlemaps/extended-component-library/src/store_locator/distances.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {APILoader} from '../api_loader/api_loader.js';\nimport {LatLng, LatLngLiteral} from '../utils/googlemaps_types.js';\nimport {RequestCache} from '../utils/request_cache.js';\n\nconst CACHE_SIZE = 10;\nconst MAX_DISTANCE_MATRIX_DESTINATIONS = 25;\n\nfunction makeDistanceMatrixRequestCache() {\n  return new RequestCache<\n      google.maps.DistanceMatrixRequest, google.maps.DistanceMatrixResponse,\n      google.maps.MapsRequestError>(\n      CACHE_SIZE, (error: google.maps.MapsRequestError) => {\n        // Requests with a transient error of OVER_QUERY_LIMIT\n        // and UNKNOWN_ERROR should be retried. See full list of statuses\n        // https://developers.google.com/maps/documentation/javascript/reference/distance-matrix#DistanceMatrixStatus\n        return error.code ===\n            'OVER_QUERY_LIMIT' as google.maps.DistanceMatrixStatus ||\n            error.code === 'UNKNOWN_ERROR' as google.maps.DistanceMatrixStatus;\n      });\n}\n\n/** How a distance was calculated. */\nexport enum DistanceSource {\n  GEOMETRIC,\n  DISTANCE_MATRIX\n}\n\n/** Distance measurement between two locations. */\nexport interface DistanceInfo {\n  value?: number;\n  text?: string;\n  source?: DistanceSource;\n}\n\ntype Destination = LatLng|LatLngLiteral;\n\n/**\n * A utility for calculating distances from a single point to N other points.\n *\n * This class combines the Maps JS Distance Matrix API with a global request\n * cache and a fallback for when N is more than allowed by the API.\n */\nexport class DistanceMeasurer {\n  private static service?: google.maps.DistanceMatrixService;\n  private static cache = makeDistanceMatrixRequestCache();\n\n  constructor(private readonly elementForLogging?: HTMLElement) {}\n\n  /**\n   * Computes travel distance between `origin` and each of the `destinations`.\n   *\n   * If there are more than 25 `destinations`, the Distance Matrix API cannot\n   * process them in a single request. In this case, the method will assign\n   * a geometric distance to all N `destinations`, then use Distance Matrix\n   * to compute accurate distances to the nearest 25 options.\n   */\n  async computeDistances(\n      origin: LatLng|LatLngLiteral, destinations: Array<LatLng|LatLngLiteral>,\n      units: google.maps.UnitSystem): Promise<DistanceInfo[]> {\n    const distances = new Map<Destination, DistanceInfo>();\n    for (const destination of destinations) {\n      distances.set(destination, {});\n    }\n\n    let destinationsForLookup = [...destinations];\n    if (destinations.length > MAX_DISTANCE_MATRIX_DESTINATIONS) {\n      // Too many `destinations` for Distance Matrix; start by calculating\n      // geometric distance.\n      const {spherical} =\n          await APILoader.importLibrary('geometry', this.elementForLogging) as\n          google.maps.GeometryLibrary;\n      for (const [destination, distanceInfo] of distances.entries()) {\n        distanceInfo.source = DistanceSource.GEOMETRIC;\n        distanceInfo.value =\n            spherical.computeDistanceBetween(origin, destination);\n      }\n\n      // Take the top 25 closest points to refine via Distance Matrix.\n      const getSphericalDistance = (p: Destination) =>\n          distances.get(p)?.value ?? Infinity;\n      destinationsForLookup.sort(\n          (a, b) => getSphericalDistance(a) - getSphericalDistance(b));\n      destinationsForLookup =\n          destinationsForLookup.slice(0, MAX_DISTANCE_MATRIX_DESTINATIONS);\n    }\n\n    const request: google.maps.DistanceMatrixRequest = {\n      origins: [origin],\n      destinations: destinationsForLookup,\n      travelMode: 'DRIVING' as google.maps.TravelMode,\n      unitSystem: units,\n    };\n    let responsePromise = DistanceMeasurer.cache.get(request);\n    if (responsePromise == null) {\n      responsePromise = this.getService().then(\n          (service) => service.getDistanceMatrix(request));\n      DistanceMeasurer.cache.set(request, responsePromise);\n    }\n    const response = await responsePromise;\n    for (let i = 0; i < response.rows[0].elements.length; i++) {\n      const distanceInfo = distances.get(destinationsForLookup[i])!;\n      const apiResult = response.rows[0].elements[i];\n      if (apiResult.status === 'OK') {\n        distanceInfo.value = apiResult.distance.value;\n        distanceInfo.text = apiResult.distance.text;\n        distanceInfo.source = DistanceSource.DISTANCE_MATRIX;\n      }\n    }\n\n    return destinations.map(destination => distances.get(destination)!);\n  }\n\n  private async getService(): Promise<google.maps.DistanceMatrixService> {\n    if (!DistanceMeasurer.service) {\n      const {DistanceMatrixService} =\n          await APILoader.importLibrary('routes', this.elementForLogging) as\n          google.maps.RoutesLibrary;\n      DistanceMeasurer.service = new DistanceMatrixService();\n    }\n    return DistanceMeasurer.service;\n  }\n\n  /**\n   * Resets Distance Measurer state by deleting any existing service object\n   * and clearing its cache.\n   * This method should be invoked for testing purposes only.\n   * @ignore\n   */\n  static reset() {\n    DistanceMeasurer.cache = makeDistanceMatrixRequestCache();\n    DistanceMeasurer.service = undefined;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}