{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate, __metadata } from \"tslib\";\nimport { css, html, nothing } from 'lit';\nimport { customElement, property } from 'lit/decorators.js';\nimport { when } from 'lit/directives/when.js';\nimport { PlaceDataConsumer } from '../place_data_consumer.js';\n/**\n * Supported field names for `PlaceFieldLink`, formatted as `Place` fields.\n */\nexport const PLACE_LINK_FIELDS = ['googleMapsURI', 'websiteURI'];\n/**\n * Supported field names for `PlaceFieldLink`, formatted as `PlaceResult`\n * fields.\n */\nexport const PLACE_RESULT_LINK_FIELDS = ['url', 'website'];\nfunction toPlaceLinkField(field) {\n  switch (field) {\n    case 'url':\n      return 'googleMapsURI';\n    case 'website':\n      return 'websiteURI';\n    default:\n      return field;\n  }\n}\nfunction getFieldValue(place, field) {\n  switch (toPlaceLinkField(field)) {\n    case 'googleMapsURI':\n      return place.googleMapsURI;\n    case 'websiteURI':\n      return place.websiteURI;\n    default:\n      return undefined;\n  }\n}\nfunction getUrlDomain(url) {\n  const match = url.match(/^(https?:\\/\\/)?(www\\.)?([^\\/\\?]+)/);\n  return match && match.length > 3 ? match[3] : url;\n}\n/**\n * Component that renders an anchor tag to one of this place's URLs:\n * `websiteURI` or `googleMapsURI`. By default, renders a link to `websiteURI`\n * with the URL's domain as the text.\n */\nlet PlaceFieldLink = class PlaceFieldLink extends PlaceDataConsumer {\n  constructor() {\n    super(...arguments);\n    /**\n     * The field to link to, formatted as it is on either a `Place` or\n     * `PlaceResult`.\n     *\n     * Allowed fields are: `googleMapsURI` or `url` for a link to this place on\n     * Google Maps; `websiteURI` or `website` for a link to this place's\n     * website.\n     */\n    this.hrefField = 'websiteURI';\n    /**\n     * The link description that gets read by assistive technology.\n     *\n     * Set this to something more descriptive if the link's purpose isn't clear\n     * from its text content alone. For example, if the link text is just\n     * \"Website\", then the `aria-label` could be \"Website for (business name)\".\n     */\n    this.ariaLabel = null;\n  }\n  render() {\n    const href = this.getHref();\n    // clang-format off\n    return html`${when(href, () => html`\n      <a target=\"_blank\" rel=\"noopener noreferrer\" href=${href}\n          aria-label=${this.ariaLabel ?? nothing}>\n        ${when(this.hasContentForSlot(), () => html`<slot></slot>`, () => html`${this.getDefaultLinkText(href)}`)}\n      </a>\n    `)}`;\n    // clang-format on\n  }\n  updated() {\n    // If the aria-label attribute is set, hide it from the a11y tree. Otherwise\n    // the component and its shadow DOM content show up as duplicate nodes with\n    // the same aria-label.\n    this.role = this.ariaLabel != null ? 'none' : null;\n  }\n  /** @ignore */\n  getRequiredFields() {\n    return [toPlaceLinkField(this.hrefField)];\n  }\n  placeHasData(place) {\n    return getFieldValue(place, this.hrefField) != null;\n  }\n  getHref() {\n    const place = this.getPlace();\n    if (!place) return null;\n    return getFieldValue(place, this.hrefField) ?? null;\n  }\n  hasContentForSlot() {\n    return !!(this.textContent?.trim() || this.children.length > 0);\n  }\n  getDefaultLinkText(href) {\n    switch (toPlaceLinkField(this.hrefField)) {\n      case 'googleMapsURI':\n        return 'View on Google Maps';\n      case 'websiteURI':\n      default:\n        return getUrlDomain(href);\n    }\n  }\n};\nPlaceFieldLink.styles = css`\n    :host(:hover) {\n      text-decoration: underline;\n    }\n\n    a {\n      color: inherit;\n      text-decoration: inherit;\n    }\n  `;\n__decorate([property({\n  type: String,\n  reflect: true,\n  attribute: 'href-field'\n}), __metadata(\"design:type\", String)], PlaceFieldLink.prototype, \"hrefField\", void 0);\n__decorate([property({\n  attribute: 'aria-label',\n  reflect: true,\n  type: String\n}), __metadata(\"design:type\", Object)], PlaceFieldLink.prototype, \"ariaLabel\", void 0);\nPlaceFieldLink = __decorate([customElement('gmpx-place-field-link')], PlaceFieldLink);\nexport { PlaceFieldLink };","map":{"version":3,"names":["css","html","nothing","customElement","property","when","PlaceDataConsumer","PLACE_LINK_FIELDS","PLACE_RESULT_LINK_FIELDS","toPlaceLinkField","field","getFieldValue","place","googleMapsURI","websiteURI","undefined","getUrlDomain","url","match","length","PlaceFieldLink","constructor","hrefField","ariaLabel","render","href","getHref","hasContentForSlot","getDefaultLinkText","updated","role","getRequiredFields","placeHasData","getPlace","textContent","trim","children","styles","__decorate","type","String","reflect","attribute"],"sources":["/Users/achiladilshan/Desktop/travelmate/client/node_modules/@googlemaps/extended-component-library/src/place_building_blocks/place_field_link/place_field_link.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {css, html, nothing} from 'lit';\nimport {customElement, property} from 'lit/decorators.js';\nimport {when} from 'lit/directives/when.js';\n\nimport type {Place} from '../../utils/googlemaps_types.js';\nimport {PlaceDataConsumer} from '../place_data_consumer.js';\n\n\n/**\n * Supported field names for `PlaceFieldLink`, formatted as `Place` fields.\n */\nexport const PLACE_LINK_FIELDS = [\n  'googleMapsURI',\n  'websiteURI',\n] as const;\n\n/**\n * Supported field names for `PlaceFieldLink`, formatted as `PlaceResult`\n * fields.\n */\nexport const PLACE_RESULT_LINK_FIELDS = [\n  'url',\n  'website',\n] as const;\n\ntype PlaceLinkField = typeof PLACE_LINK_FIELDS[number];\ntype PlaceResultLinkField = typeof PLACE_RESULT_LINK_FIELDS[number];\n/**\n * String union type of all supported field names for `PlaceFieldLink`.\n */\nexport type LinkField = PlaceLinkField|PlaceResultLinkField;\n\nfunction toPlaceLinkField(field: LinkField): PlaceLinkField {\n  switch (field) {\n    case 'url':\n      return 'googleMapsURI';\n    case 'website':\n      return 'websiteURI';\n    default:\n      return field;\n  }\n}\n\nfunction getFieldValue(place: Place, field: LinkField): string|null|undefined {\n  switch (toPlaceLinkField(field)) {\n    case 'googleMapsURI':\n      return place.googleMapsURI;\n    case 'websiteURI':\n      return place.websiteURI;\n    default:\n      return undefined;\n  }\n}\n\nfunction getUrlDomain(url: string): string {\n  const match = url.match(/^(https?:\\/\\/)?(www\\.)?([^\\/\\?]+)/);\n  return (match && match.length > 3) ? match[3] : url;\n}\n\n/**\n * Component that renders an anchor tag to one of this place's URLs:\n * `websiteURI` or `googleMapsURI`. By default, renders a link to `websiteURI`\n * with the URL's domain as the text.\n */\n@customElement('gmpx-place-field-link')\nexport class PlaceFieldLink extends PlaceDataConsumer {\n  static override styles = css`\n    :host(:hover) {\n      text-decoration: underline;\n    }\n\n    a {\n      color: inherit;\n      text-decoration: inherit;\n    }\n  `;\n\n  /**\n   * The field to link to, formatted as it is on either a `Place` or\n   * `PlaceResult`.\n   *\n   * Allowed fields are: `googleMapsURI` or `url` for a link to this place on\n   * Google Maps; `websiteURI` or `website` for a link to this place's\n   * website.\n   */\n  @property({type: String, reflect: true, attribute: 'href-field'})\n  hrefField: LinkField = 'websiteURI';\n\n  /**\n   * The link description that gets read by assistive technology.\n   *\n   * Set this to something more descriptive if the link's purpose isn't clear\n   * from its text content alone. For example, if the link text is just\n   * \"Website\", then the `aria-label` could be \"Website for (business name)\".\n   */\n  @property({attribute: 'aria-label', reflect: true, type: String})\n  override ariaLabel: string|null = null;\n\n  protected override render() {\n    const href = this.getHref();\n    // clang-format off\n    return html`${when(href, () => html`\n      <a target=\"_blank\" rel=\"noopener noreferrer\" href=${href!}\n          aria-label=${this.ariaLabel ?? nothing}>\n        ${when(this.hasContentForSlot(),\n          () => html`<slot></slot>`,\n          () => html`${this.getDefaultLinkText(href!)}`,\n        )}\n      </a>\n    `,)}`;\n    // clang-format on\n  }\n\n  protected override updated() {\n    // If the aria-label attribute is set, hide it from the a11y tree. Otherwise\n    // the component and its shadow DOM content show up as duplicate nodes with\n    // the same aria-label.\n    this.role = this.ariaLabel != null ? 'none' : null;\n  }\n\n  /** @ignore */\n  getRequiredFields(): Array<keyof Place> {\n    return [toPlaceLinkField(this.hrefField)];\n  }\n\n  protected override placeHasData(place: Place): boolean {\n    return (getFieldValue(place, this.hrefField) != null);\n  }\n\n  private getHref(): string|null {\n    const place = this.getPlace();\n    if (!place) return null;\n    return getFieldValue(place, this.hrefField) ?? null;\n  }\n\n  private hasContentForSlot(): boolean {\n    return !!(this.textContent?.trim() || (this.children.length > 0));\n  }\n\n  private getDefaultLinkText(href: string): string {\n    switch (toPlaceLinkField(this.hrefField)) {\n      case 'googleMapsURI':\n        return 'View on Google Maps';\n      case 'websiteURI':\n      default:\n        return getUrlDomain(href);\n    }\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'gmpx-place-field-link': PlaceFieldLink;\n  }\n}\n"],"mappings":"AAAA;;;;;;AAMA,SAAQA,GAAG,EAAEC,IAAI,EAAEC,OAAO,QAAO,KAAK;AACtC,SAAQC,aAAa,EAAEC,QAAQ,QAAO,mBAAmB;AACzD,SAAQC,IAAI,QAAO,wBAAwB;AAG3C,SAAQC,iBAAiB,QAAO,2BAA2B;AAG3D;;;AAGA,OAAO,MAAMC,iBAAiB,GAAG,CAC/B,eAAe,EACf,YAAY,CACJ;AAEV;;;;AAIA,OAAO,MAAMC,wBAAwB,GAAG,CACtC,KAAK,EACL,SAAS,CACD;AASV,SAASC,gBAAgBA,CAACC,KAAgB;EACxC,QAAQA,KAAK;IACX,KAAK,KAAK;MACR,OAAO,eAAe;IACxB,KAAK,SAAS;MACZ,OAAO,YAAY;IACrB;MACE,OAAOA,KAAK;;AAElB;AAEA,SAASC,aAAaA,CAACC,KAAY,EAAEF,KAAgB;EACnD,QAAQD,gBAAgB,CAACC,KAAK,CAAC;IAC7B,KAAK,eAAe;MAClB,OAAOE,KAAK,CAACC,aAAa;IAC5B,KAAK,YAAY;MACf,OAAOD,KAAK,CAACE,UAAU;IACzB;MACE,OAAOC,SAAS;;AAEtB;AAEA,SAASC,YAAYA,CAACC,GAAW;EAC/B,MAAMC,KAAK,GAAGD,GAAG,CAACC,KAAK,CAAC,mCAAmC,CAAC;EAC5D,OAAQA,KAAK,IAAIA,KAAK,CAACC,MAAM,GAAG,CAAC,GAAID,KAAK,CAAC,CAAC,CAAC,GAAGD,GAAG;AACrD;AAEA;;;;;AAMO,IAAMG,cAAc,GAApB,MAAMA,cAAe,SAAQd,iBAAiB;EAA9Ce,YAAA;;IAYL;;;;;;;;IASA,KAAAC,SAAS,GAAc,YAAY;IAEnC;;;;;;;IAQS,KAAAC,SAAS,GAAgB,IAAI;EAoDxC;EAlDqBC,MAAMA,CAAA;IACvB,MAAMC,IAAI,GAAG,IAAI,CAACC,OAAO,EAAE;IAC3B;IACA,OAAOzB,IAAI,GAAGI,IAAI,CAACoB,IAAI,EAAE,MAAMxB,IAAI;0DACmBwB,IAAK;uBACxC,IAAI,CAACF,SAAS,IAAIrB,OAAO;UACtCG,IAAI,CAAC,IAAI,CAACsB,iBAAiB,EAAE,EAC7B,MAAM1B,IAAI,eAAe,EACzB,MAAMA,IAAI,GAAG,IAAI,CAAC2B,kBAAkB,CAACH,IAAK,CAAC,EAAE,CAC9C;;KAEJ,CAAE,EAAE;IACL;EACF;EAEmBI,OAAOA,CAAA;IACxB;IACA;IACA;IACA,IAAI,CAACC,IAAI,GAAG,IAAI,CAACP,SAAS,IAAI,IAAI,GAAG,MAAM,GAAG,IAAI;EACpD;EAEA;EACAQ,iBAAiBA,CAAA;IACf,OAAO,CAACtB,gBAAgB,CAAC,IAAI,CAACa,SAAS,CAAC,CAAC;EAC3C;EAEmBU,YAAYA,CAACpB,KAAY;IAC1C,OAAQD,aAAa,CAACC,KAAK,EAAE,IAAI,CAACU,SAAS,CAAC,IAAI,IAAI;EACtD;EAEQI,OAAOA,CAAA;IACb,MAAMd,KAAK,GAAG,IAAI,CAACqB,QAAQ,EAAE;IAC7B,IAAI,CAACrB,KAAK,EAAE,OAAO,IAAI;IACvB,OAAOD,aAAa,CAACC,KAAK,EAAE,IAAI,CAACU,SAAS,CAAC,IAAI,IAAI;EACrD;EAEQK,iBAAiBA,CAAA;IACvB,OAAO,CAAC,EAAE,IAAI,CAACO,WAAW,EAAEC,IAAI,EAAE,IAAK,IAAI,CAACC,QAAQ,CAACjB,MAAM,GAAG,CAAE,CAAC;EACnE;EAEQS,kBAAkBA,CAACH,IAAY;IACrC,QAAQhB,gBAAgB,CAAC,IAAI,CAACa,SAAS,CAAC;MACtC,KAAK,eAAe;QAClB,OAAO,qBAAqB;MAC9B,KAAK,YAAY;MACjB;QACE,OAAON,YAAY,CAACS,IAAI,CAAC;;EAE/B;;AAjFgBL,cAAA,CAAAiB,MAAM,GAAGrC,GAAG;;;;;;;;;GAS3B;AAWDsC,UAAA,EADClC,QAAQ,CAAC;EAACmC,IAAI,EAAEC,MAAM;EAAEC,OAAO,EAAE,IAAI;EAAEC,SAAS,EAAE;AAAY,CAAC,CAAC,E,kFAC7B;AAU3BJ,UAAA,EADRlC,QAAQ,CAAC;EAACsC,SAAS,EAAE,YAAY;EAAED,OAAO,EAAE,IAAI;EAAEF,IAAI,EAAEC;AAAM,CAAC,CAAC,E,kFAC1B;AA/B5BpB,cAAc,GAAAkB,UAAA,EAD1BnC,aAAa,CAAC,uBAAuB,CAAC,C,EAC1BiB,cAAc,CAmF1B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}