{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst ONE_DAY_IN_MS = 24 * 60 * 60 * 1000;\nconst ONE_WEEK_IN_MS = 7 * ONE_DAY_IN_MS;\n/**\n * Formats a relative point in time according to the browser's locale format.\n */\nfunction formatPointTime(point, includeWeekday = false) {\n  // Choose an arbitrary `Date`, then set the fields needed for formatting\n  // (weekday and time).\n  const date = new Date();\n  date.setDate(date.getDate() - date.getDay() + point.day);\n  date.setHours(point.hour);\n  date.setMinutes(point.minute);\n  date.setSeconds(0);\n  return date.toLocaleString( /* locales= */undefined, {\n    hour: 'numeric',\n    minute: 'numeric',\n    weekday: includeWeekday ? 'short' : undefined\n  });\n}\n/**\n * Formats a relative point in time (specified in the Place's TZ), usually\n * including the weekday. However, if the point in time, as an absolute\n * timestamp, occurs within the next 24 hours, hide the weekday.\n *\n * @param point The relative time from the Places API (weekday, hour, minute)\n * @param absolutePoint The instant in time corresponding to `point`, i.e. a\n *     `Date` object\n * @param now Used to determine if `absolutePoint` is coming soon\n */\nexport function formatTimeWithWeekdayMaybe(point, absolutePoint, now = new Date()) {\n  return formatPointTime(point, !isSoon(absolutePoint, now));\n}\n/**\n * Returns whether the given date is in the future and soon approaching. \"Soon\"\n * means sooner than the `intervalMs` argument (default 24 hours).\n */\nexport function isSoon(date, now = new Date(), intervalMs = ONE_DAY_IN_MS) {\n  return date >= now && date.valueOf() - now.valueOf() < intervalMs;\n}\n/** Detects if a Place is declared as always open. */\nfunction isPlaceAlwaysOpen(openingHours) {\n  return openingHours.periods?.length === 1 && !openingHours.periods[0].close && openingHours.periods[0].open.day === 0 && openingHours.periods[0].open.hour === 0 && openingHours.periods[0].open.minute === 0;\n}\n/** Gets the date components of the most recent Sunday (relative to UTC). */\nfunction getLastSundayUTC(date) {\n  const sundayUTC = new Date(date);\n  sundayUTC.setUTCDate(sundayUTC.getUTCDate() - sundayUTC.getUTCDay());\n  return {\n    year: sundayUTC.getUTCFullYear(),\n    month: sundayUTC.getUTCMonth(),\n    day: sundayUTC.getUTCDate()\n  };\n}\n/**\n * From all occurrences of \"Sunday at 00:00\" in the Place's timezone, return\n * the most recent one prior to `now`.\n */\nfunction getLastSundayInPlaceTimezone(now, utcOffsetMinutes) {\n  const {\n    year,\n    month,\n    day\n  } = getLastSundayUTC(now);\n  let placeSundayStart = Date.UTC(year, month, day, 0, -utcOffsetMinutes);\n  // Because of the offset, `placeSundayStart` could be after `now` or more\n  // than 7 days before it. Increment as necessary.\n  const deltaBeforeNowMs = now.valueOf() - placeSundayStart;\n  if (deltaBeforeNowMs < 0) {\n    placeSundayStart -= ONE_WEEK_IN_MS;\n  } else if (deltaBeforeNowMs >= ONE_WEEK_IN_MS) {\n    placeSundayStart += ONE_WEEK_IN_MS;\n  }\n  return new Date(placeSundayStart);\n}\n/**\n * Converts a relative `OpeningHoursPoint` object into an absolute timestamp,\n * indexed off of `placeSundayStart`.\n */\nfunction getPointDate(point, placeSundayStart) {\n  const pointDate = new Date(placeSundayStart);\n  pointDate.setDate(pointDate.getDate() + point.day);\n  pointDate.setHours(pointDate.getHours() + point.hour);\n  pointDate.setMinutes(pointDate.getMinutes() + point.minute);\n  return pointDate;\n}\n/**\n * Finds the currently active Opening Hours Period, if any, along with its\n * absolute open and closing timestamps.\n */\nfunction getCurrentPeriod(openingHours, utcOffsetMinutes, now = new Date()) {\n  const lastSundayStart = getLastSundayInPlaceTimezone(now, utcOffsetMinutes);\n  for (const period of openingHours.periods) {\n    const stats = {\n      period,\n      openDate: getPointDate(period.open, lastSundayStart),\n      closeDate: period.close ? getPointDate(period.close, lastSundayStart) : undefined\n    };\n    if (!stats.closeDate) {\n      return stats;\n    }\n    // In situations where the local close time appears earlier than the open\n    // time, e.g. \"Opens Saturday (6), closes Sunday (0)\", create a forward\n    // interval.\n    if (stats.closeDate < stats.openDate) {\n      if (stats.openDate > now) {\n        stats.openDate.setDate(stats.openDate.getDate() - 7);\n      } else {\n        stats.closeDate.setDate(stats.closeDate.getDate() + 7);\n      }\n    }\n    if (now >= stats.openDate && now < stats.closeDate) {\n      return stats;\n    }\n  }\n  return {};\n}\n/** Status indicator for an upcoming close time. */\nexport var NextCloseTimeStatus;\n(function (NextCloseTimeStatus) {\n  NextCloseTimeStatus[NextCloseTimeStatus[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  NextCloseTimeStatus[NextCloseTimeStatus[\"ALWAYS_OPEN\"] = 1] = \"ALWAYS_OPEN\";\n  NextCloseTimeStatus[NextCloseTimeStatus[\"NOT_OPEN_NOW\"] = 2] = \"NOT_OPEN_NOW\";\n  NextCloseTimeStatus[NextCloseTimeStatus[\"WILL_CLOSE\"] = 3] = \"WILL_CLOSE\";\n})(NextCloseTimeStatus || (NextCloseTimeStatus = {}));\n/**\n * Finds the next closing time of a Place, returning it (if present) and a\n * status flag.\n *\n * Does not take into account exceptional hours (such as holidays) or business\n * status.\n */\nexport function getUpcomingCloseTime(place, now = new Date()) {\n  if (!place.regularOpeningHours || place.utcOffsetMinutes == null) {\n    return {\n      status: NextCloseTimeStatus.UNKNOWN\n    };\n  } else if (isPlaceAlwaysOpen(place.regularOpeningHours)) {\n    return {\n      status: NextCloseTimeStatus.ALWAYS_OPEN\n    };\n  }\n  const currentPeriod = getCurrentPeriod(place.regularOpeningHours, place.utcOffsetMinutes, now);\n  if (!currentPeriod.period) {\n    return {\n      status: NextCloseTimeStatus.NOT_OPEN_NOW\n    };\n  } else if (!currentPeriod.closeDate) {\n    // This should not happen unless we receive malformed data; \"always open\"\n    // should be caught by the `isPlaceAlwaysOpen()` check above.\n    return {\n      status: NextCloseTimeStatus.ALWAYS_OPEN\n    };\n  }\n  return {\n    status: NextCloseTimeStatus.WILL_CLOSE,\n    closeDate: currentPeriod.closeDate,\n    // Always defined if `currentPeriod.closeDate` is\n    closePoint: currentPeriod.period.close\n  };\n}\n/** Status indicator for an upcoming opening time. */\nexport var NextOpenTimeStatus;\n(function (NextOpenTimeStatus) {\n  NextOpenTimeStatus[NextOpenTimeStatus[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  NextOpenTimeStatus[NextOpenTimeStatus[\"NEVER_OPEN\"] = 1] = \"NEVER_OPEN\";\n  NextOpenTimeStatus[NextOpenTimeStatus[\"ALREADY_OPEN\"] = 2] = \"ALREADY_OPEN\";\n  NextOpenTimeStatus[NextOpenTimeStatus[\"WILL_OPEN\"] = 3] = \"WILL_OPEN\";\n})(NextOpenTimeStatus || (NextOpenTimeStatus = {}));\n/**\n * Finds the next open time of a Place, returning it (if present) and a\n * status flag.\n *\n * Does not take into account exceptional hours (such as holidays) or business\n * status.\n */\nexport function getUpcomingOpenTime(place, now = new Date()) {\n  if (!place.regularOpeningHours || place.utcOffsetMinutes == null) {\n    return {\n      status: NextOpenTimeStatus.UNKNOWN\n    };\n  } else if (isPlaceAlwaysOpen(place.regularOpeningHours)) {\n    return {\n      status: NextOpenTimeStatus.ALREADY_OPEN\n    };\n  }\n  const lastSundayStart = getLastSundayInPlaceTimezone(now, place.utcOffsetMinutes);\n  const bestResult = {\n    status: NextOpenTimeStatus.NEVER_OPEN\n  };\n  let closestOpenInterval = Infinity;\n  for (const period of place.regularOpeningHours.periods) {\n    const openDate = getPointDate(period.open, lastSundayStart);\n    if (!period.close) {\n      return {\n        status: NextOpenTimeStatus.ALREADY_OPEN\n      };\n    }\n    const closeDate = getPointDate(period.close, lastSundayStart);\n    if (closeDate >= openDate && now >= openDate && now < closeDate) {\n      return {\n        status: NextOpenTimeStatus.ALREADY_OPEN\n      };\n    } else if (closeDate < openDate && !(now >= closeDate && now < openDate)) {\n      return {\n        status: NextOpenTimeStatus.ALREADY_OPEN\n      };\n    }\n    // Make sure openDate is in the future\n    if (openDate < now) {\n      openDate.setDate(openDate.getDate() + 7);\n    }\n    const interval = openDate.valueOf() - now.valueOf();\n    if (interval < closestOpenInterval) {\n      closestOpenInterval = interval;\n      bestResult.status = NextOpenTimeStatus.WILL_OPEN;\n      bestResult.openPoint = period.open;\n      bestResult.openDate = openDate;\n    }\n  }\n  return bestResult;\n}\n/**\n * Temporary (until Place is GA) replacement for the built-in isOpen() method.\n */\nexport function isOpen(place, now = new Date()) {\n  if (!place.regularOpeningHours || place.utcOffsetMinutes == null) {\n    return undefined;\n  } else if (isPlaceAlwaysOpen(place.regularOpeningHours)) {\n    return true;\n  }\n  const {\n    period\n  } = getCurrentPeriod(place.regularOpeningHours, place.utcOffsetMinutes, now);\n  return !!period;\n}","map":{"version":3,"names":["ONE_DAY_IN_MS","ONE_WEEK_IN_MS","formatPointTime","point","includeWeekday","date","Date","setDate","getDate","getDay","day","setHours","hour","setMinutes","minute","setSeconds","toLocaleString","undefined","weekday","formatTimeWithWeekdayMaybe","absolutePoint","now","isSoon","intervalMs","valueOf","isPlaceAlwaysOpen","openingHours","periods","length","close","open","getLastSundayUTC","sundayUTC","setUTCDate","getUTCDate","getUTCDay","year","getUTCFullYear","month","getUTCMonth","getLastSundayInPlaceTimezone","utcOffsetMinutes","placeSundayStart","UTC","deltaBeforeNowMs","getPointDate","pointDate","getHours","getMinutes","getCurrentPeriod","lastSundayStart","period","stats","openDate","closeDate","NextCloseTimeStatus","getUpcomingCloseTime","place","regularOpeningHours","status","UNKNOWN","ALWAYS_OPEN","currentPeriod","NOT_OPEN_NOW","WILL_CLOSE","closePoint","NextOpenTimeStatus","getUpcomingOpenTime","ALREADY_OPEN","bestResult","NEVER_OPEN","closestOpenInterval","Infinity","interval","WILL_OPEN","openPoint","isOpen"],"sources":["/Users/achiladilshan/Desktop/travelmate/client/node_modules/@googlemaps/extended-component-library/src/utils/opening_hours.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Place} from './googlemaps_types.js';\n\nconst ONE_DAY_IN_MS = 24 * 60 * 60 * 1000;\nconst ONE_WEEK_IN_MS = 7 * ONE_DAY_IN_MS;\n\ntype OpeningHours = google.maps.places.OpeningHours;\ntype OpeningHoursPeriod = google.maps.places.OpeningHoursPeriod;\ntype OpeningHoursPoint = google.maps.places.OpeningHoursPoint;\n\n/**\n * Formats a relative point in time according to the browser's locale format.\n */\nfunction formatPointTime(\n    point: OpeningHoursPoint, includeWeekday = false): string {\n  // Choose an arbitrary `Date`, then set the fields needed for formatting\n  // (weekday and time).\n  const date = new Date();\n  date.setDate(date.getDate() - date.getDay() + point.day);\n  date.setHours(point.hour);\n  date.setMinutes(point.minute);\n  date.setSeconds(0);\n\n  return date.toLocaleString(\n      /* locales= */ undefined, {\n        hour: 'numeric',\n        minute: 'numeric',\n        weekday: includeWeekday ? 'short' : undefined\n      });\n}\n\n/**\n * Formats a relative point in time (specified in the Place's TZ), usually\n * including the weekday. However, if the point in time, as an absolute\n * timestamp, occurs within the next 24 hours, hide the weekday.\n *\n * @param point The relative time from the Places API (weekday, hour, minute)\n * @param absolutePoint The instant in time corresponding to `point`, i.e. a\n *     `Date` object\n * @param now Used to determine if `absolutePoint` is coming soon\n */\nexport function formatTimeWithWeekdayMaybe(\n    point: OpeningHoursPoint, absolutePoint: Date, now = new Date()): string {\n  return formatPointTime(point, !isSoon(absolutePoint, now));\n}\n\n/**\n * Returns whether the given date is in the future and soon approaching. \"Soon\"\n * means sooner than the `intervalMs` argument (default 24 hours).\n */\nexport function isSoon(\n    date: Date, now = new Date(), intervalMs = ONE_DAY_IN_MS): boolean {\n  return ((date >= now) && ((date.valueOf() - now.valueOf()) < intervalMs));\n}\n\n/** Detects if a Place is declared as always open. */\nfunction isPlaceAlwaysOpen(openingHours: OpeningHours): boolean {\n  return (\n      (openingHours.periods?.length === 1) && !openingHours.periods[0].close &&\n      (openingHours.periods[0].open.day === 0) &&\n      (openingHours.periods[0].open.hour === 0) &&\n      (openingHours.periods[0].open.minute === 0));\n}\n\n/** Gets the date components of the most recent Sunday (relative to UTC). */\nfunction getLastSundayUTC(date: Date):\n    {year: number, month: number, day: number} {\n  const sundayUTC = new Date(date);\n  sundayUTC.setUTCDate(sundayUTC.getUTCDate() - sundayUTC.getUTCDay());\n  return {\n    year: sundayUTC.getUTCFullYear(),\n    month: sundayUTC.getUTCMonth(),\n    day: sundayUTC.getUTCDate(),\n  };\n}\n\n/**\n * From all occurrences of \"Sunday at 00:00\" in the Place's timezone, return\n * the most recent one prior to `now`.\n */\nfunction getLastSundayInPlaceTimezone(\n    now: Date, utcOffsetMinutes: number): Date {\n  const {year, month, day} = getLastSundayUTC(now);\n  let placeSundayStart = Date.UTC(year, month, day, 0, -utcOffsetMinutes);\n\n  // Because of the offset, `placeSundayStart` could be after `now` or more\n  // than 7 days before it. Increment as necessary.\n  const deltaBeforeNowMs = now.valueOf() - placeSundayStart;\n  if (deltaBeforeNowMs < 0) {\n    placeSundayStart -= ONE_WEEK_IN_MS;\n  } else if (deltaBeforeNowMs >= ONE_WEEK_IN_MS) {\n    placeSundayStart += ONE_WEEK_IN_MS;\n  }\n  return new Date(placeSundayStart);\n}\n\n/**\n * Converts a relative `OpeningHoursPoint` object into an absolute timestamp,\n * indexed off of `placeSundayStart`.\n */\nfunction getPointDate(point: OpeningHoursPoint, placeSundayStart: Date): Date {\n  const pointDate = new Date(placeSundayStart);\n  pointDate.setDate(pointDate.getDate() + point.day);\n  pointDate.setHours(pointDate.getHours() + point.hour);\n  pointDate.setMinutes(pointDate.getMinutes() + point.minute);\n  return pointDate;\n}\n\n/**\n * Finds the currently active Opening Hours Period, if any, along with its\n * absolute open and closing timestamps.\n */\nfunction getCurrentPeriod(\n    openingHours: OpeningHours, utcOffsetMinutes: number, now = new Date()):\n    {period?: OpeningHoursPeriod, openDate?: Date, closeDate?: Date} {\n  const lastSundayStart = getLastSundayInPlaceTimezone(now, utcOffsetMinutes);\n\n  for (const period of openingHours.periods) {\n    const stats = {\n      period,\n      openDate: getPointDate(period.open, lastSundayStart),\n      closeDate: period.close ? getPointDate(period.close, lastSundayStart) :\n                                undefined\n    };\n    if (!stats.closeDate) {\n      return stats;\n    }\n\n    // In situations where the local close time appears earlier than the open\n    // time, e.g. \"Opens Saturday (6), closes Sunday (0)\", create a forward\n    // interval.\n    if (stats.closeDate < stats.openDate) {\n      if (stats.openDate > now) {\n        stats.openDate.setDate(stats.openDate.getDate() - 7);\n      } else {\n        stats.closeDate.setDate(stats.closeDate.getDate() + 7);\n      }\n    }\n\n    if ((now >= stats.openDate) && (now < stats.closeDate)) {\n      return stats;\n    }\n  }\n  return {};\n}\n\n/** Status indicator for an upcoming close time. */\nexport enum NextCloseTimeStatus {\n  UNKNOWN,\n  ALWAYS_OPEN,\n  NOT_OPEN_NOW,\n  WILL_CLOSE\n}\n\ninterface UpcomingCloseTimeResult {\n  status: NextCloseTimeStatus;\n  closePoint?: OpeningHoursPoint;\n  closeDate?: Date;\n}\n\n/**\n * Finds the next closing time of a Place, returning it (if present) and a\n * status flag.\n *\n * Does not take into account exceptional hours (such as holidays) or business\n * status.\n */\nexport function getUpcomingCloseTime(\n    place: Place, now = new Date()): UpcomingCloseTimeResult {\n  if (!place.regularOpeningHours || place.utcOffsetMinutes == null) {\n    return {status: NextCloseTimeStatus.UNKNOWN};\n  } else if (isPlaceAlwaysOpen(place.regularOpeningHours)) {\n    return {status: NextCloseTimeStatus.ALWAYS_OPEN};\n  }\n\n  const currentPeriod =\n      getCurrentPeriod(place.regularOpeningHours, place.utcOffsetMinutes, now);\n  if (!currentPeriod.period) {\n    return {status: NextCloseTimeStatus.NOT_OPEN_NOW};\n  } else if (!currentPeriod.closeDate) {\n    // This should not happen unless we receive malformed data; \"always open\"\n    // should be caught by the `isPlaceAlwaysOpen()` check above.\n    return {status: NextCloseTimeStatus.ALWAYS_OPEN};\n  }\n\n  return {\n    status: NextCloseTimeStatus.WILL_CLOSE,\n    closeDate: currentPeriod.closeDate,\n\n    // Always defined if `currentPeriod.closeDate` is\n    closePoint: currentPeriod.period.close!,\n  };\n}\n\n/** Status indicator for an upcoming opening time. */\nexport enum NextOpenTimeStatus {\n  UNKNOWN,\n  NEVER_OPEN,\n  ALREADY_OPEN,\n  WILL_OPEN\n}\n\ninterface UpcomingOpenTimeResult {\n  status: NextOpenTimeStatus;\n  openPoint?: OpeningHoursPoint;\n  openDate?: Date;\n}\n\n/**\n * Finds the next open time of a Place, returning it (if present) and a\n * status flag.\n *\n * Does not take into account exceptional hours (such as holidays) or business\n * status.\n */\nexport function getUpcomingOpenTime(\n    place: Place, now = new Date()): UpcomingOpenTimeResult {\n  if (!place.regularOpeningHours || place.utcOffsetMinutes == null) {\n    return {status: NextOpenTimeStatus.UNKNOWN};\n  } else if (isPlaceAlwaysOpen(place.regularOpeningHours)) {\n    return {status: NextOpenTimeStatus.ALREADY_OPEN};\n  }\n\n  const lastSundayStart =\n      getLastSundayInPlaceTimezone(now, place.utcOffsetMinutes);\n  const bestResult: UpcomingOpenTimeResult = {\n    status: NextOpenTimeStatus.NEVER_OPEN,\n  };\n  let closestOpenInterval = Infinity;\n  for (const period of place.regularOpeningHours.periods) {\n    const openDate = getPointDate(period.open, lastSundayStart);\n    if (!period.close) {\n      return {status: NextOpenTimeStatus.ALREADY_OPEN};\n    }\n    const closeDate = getPointDate(period.close, lastSundayStart);\n    if ((closeDate >= openDate) && (now >= openDate) && (now < closeDate)) {\n      return {status: NextOpenTimeStatus.ALREADY_OPEN};\n    } else if (\n        (closeDate < openDate) && !((now >= closeDate) && (now < openDate))) {\n      return {status: NextOpenTimeStatus.ALREADY_OPEN};\n    }\n\n    // Make sure openDate is in the future\n    if (openDate < now) {\n      openDate.setDate(openDate.getDate() + 7);\n    }\n    const interval = openDate.valueOf() - now.valueOf();\n    if (interval < closestOpenInterval) {\n      closestOpenInterval = interval;\n      bestResult.status = NextOpenTimeStatus.WILL_OPEN;\n      bestResult.openPoint = period.open;\n      bestResult.openDate = openDate;\n    }\n  }\n  return bestResult;\n}\n\n/**\n * Temporary (until Place is GA) replacement for the built-in isOpen() method.\n */\nexport function isOpen(place: Place, now = new Date()): boolean|undefined {\n  if (!place.regularOpeningHours || place.utcOffsetMinutes == null) {\n    return undefined;\n  } else if (isPlaceAlwaysOpen(place.regularOpeningHours)) {\n    return true;\n  }\n  const {period} =\n      getCurrentPeriod(place.regularOpeningHours, place.utcOffsetMinutes, now);\n  return !!period;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}