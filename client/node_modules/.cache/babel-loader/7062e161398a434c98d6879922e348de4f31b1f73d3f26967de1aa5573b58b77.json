{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { LRUMap } from './lru_map.js';\n/**\n * A limited-capacity cache keyed by serialized request objects.\n */\nexport class RequestCache {\n  /**\n   * @param capacity - The maximum number of objects to keep in the cache.\n   * @param shouldRetry - Callback that determines if a request should be\n   * retried, or if the failure should be cached.\n   */\n  constructor(capacity, shouldRetry) {\n    this.shouldRetry = shouldRetry;\n    this.requestCacheMap = new LRUMap(capacity);\n  }\n  /**\n   * Gets the cached result with the given request\n   */\n  get(request) {\n    return this.requestCacheMap.get(this.serialize(request)) ?? null;\n  }\n  /**\n   * Adds the provided request to the cache, replacing the\n   * existing result if one exists already.\n   */\n  set(key, value) {\n    const serializedKey = this.serialize(key);\n    this.requestCacheMap.set(serializedKey, value);\n    value.catch(error => {\n      if (this.shouldRetry(error)) {\n        this.requestCacheMap.delete(serializedKey);\n      }\n    });\n  }\n  /**\n   * Deterministically serializes arbitrary objects to strings.\n   */\n  serialize(request) {\n    // Non-numeric keys in modern JS are iterated in order of insertion.\n    // Make a new object and insert the keys in alphabetical order so that\n    // the object is serialized alphabetically.\n    const replacer = (key, value) => {\n      if (value instanceof Object && !(value instanceof Array)) {\n        const obj = value;\n        const sorted = {};\n        for (const key of Object.keys(obj).sort()) {\n          sorted[key] = obj[key];\n        }\n        return sorted;\n      } else {\n        return value;\n      }\n    };\n    return JSON.stringify(request, replacer);\n  }\n}","map":{"version":3,"names":["LRUMap","RequestCache","constructor","capacity","shouldRetry","requestCacheMap","get","request","serialize","set","key","value","serializedKey","catch","error","delete","replacer","Object","Array","obj","sorted","keys","sort","JSON","stringify"],"sources":["/Users/achiladilshan/Desktop/travelmate/client/node_modules/@googlemaps/extended-component-library/src/utils/request_cache.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {LRUMap} from './lru_map.js';\n\n/**\n * A limited-capacity cache keyed by serialized request objects.\n */\nexport class RequestCache<RequestType, ResponseType, ErrorType extends Error> {\n  private readonly requestCacheMap: LRUMap<string, Promise<ResponseType>>;\n  /**\n   * @param capacity - The maximum number of objects to keep in the cache.\n   * @param shouldRetry - Callback that determines if a request should be\n   * retried, or if the failure should be cached.\n   */\n  constructor(\n      capacity: number,\n      private readonly shouldRetry: (error: ErrorType) => boolean) {\n    this.requestCacheMap = new LRUMap(capacity);\n  }\n\n  /**\n   * Gets the cached result with the given request\n   */\n  get(request: RequestType): Promise<ResponseType>|null {\n    return this.requestCacheMap.get(this.serialize(request)) ?? null;\n  }\n\n  /**\n   * Adds the provided request to the cache, replacing the\n   * existing result if one exists already.\n   */\n  set(key: RequestType, value: Promise<ResponseType>) {\n    const serializedKey = this.serialize(key);\n    this.requestCacheMap.set(serializedKey, value);\n    value.catch((error: ErrorType) => {\n      if (this.shouldRetry(error)) {\n        this.requestCacheMap.delete(serializedKey);\n      }\n    });\n  }\n\n  /**\n   * Deterministically serializes arbitrary objects to strings.\n   */\n  private serialize(request: RequestType): string {\n    interface UnknownObject {\n      [key: string]: unknown;\n    }\n\n    // Non-numeric keys in modern JS are iterated in order of insertion.\n    // Make a new object and insert the keys in alphabetical order so that\n    // the object is serialized alphabetically.\n    const replacer = (key: string, value: unknown) => {\n      if (value instanceof Object && !(value instanceof Array)) {\n        const obj = value as UnknownObject;\n        const sorted: UnknownObject = {};\n        for (const key of Object.keys(obj).sort()) {\n          sorted[key] = obj[key];\n        }\n        return sorted;\n      } else {\n        return value;\n      }\n    };\n    return JSON.stringify(request, replacer);\n  }\n}"],"mappings":"AAAA;;;;;AAMA,SAAQA,MAAM,QAAO,cAAc;AAEnC;;;AAGA,OAAM,MAAOC,YAAY;EAEvB;;;;;EAKAC,YACIC,QAAgB,EACCC,WAA0C;IAA1C,KAAAA,WAAW,GAAXA,WAAW;IAC9B,IAAI,CAACC,eAAe,GAAG,IAAIL,MAAM,CAACG,QAAQ,CAAC;EAC7C;EAEA;;;EAGAG,GAAGA,CAACC,OAAoB;IACtB,OAAO,IAAI,CAACF,eAAe,CAACC,GAAG,CAAC,IAAI,CAACE,SAAS,CAACD,OAAO,CAAC,CAAC,IAAI,IAAI;EAClE;EAEA;;;;EAIAE,GAAGA,CAACC,GAAgB,EAAEC,KAA4B;IAChD,MAAMC,aAAa,GAAG,IAAI,CAACJ,SAAS,CAACE,GAAG,CAAC;IACzC,IAAI,CAACL,eAAe,CAACI,GAAG,CAACG,aAAa,EAAED,KAAK,CAAC;IAC9CA,KAAK,CAACE,KAAK,CAAEC,KAAgB,IAAI;MAC/B,IAAI,IAAI,CAACV,WAAW,CAACU,KAAK,CAAC,EAAE;QAC3B,IAAI,CAACT,eAAe,CAACU,MAAM,CAACH,aAAa,CAAC;;IAE9C,CAAC,CAAC;EACJ;EAEA;;;EAGQJ,SAASA,CAACD,OAAoB;IAKpC;IACA;IACA;IACA,MAAMS,QAAQ,GAAGA,CAACN,GAAW,EAAEC,KAAc,KAAI;MAC/C,IAAIA,KAAK,YAAYM,MAAM,IAAI,EAAEN,KAAK,YAAYO,KAAK,CAAC,EAAE;QACxD,MAAMC,GAAG,GAAGR,KAAsB;QAClC,MAAMS,MAAM,GAAkB,EAAE;QAChC,KAAK,MAAMV,GAAG,IAAIO,MAAM,CAACI,IAAI,CAACF,GAAG,CAAC,CAACG,IAAI,EAAE,EAAE;UACzCF,MAAM,CAACV,GAAG,CAAC,GAAGS,GAAG,CAACT,GAAG,CAAC;;QAExB,OAAOU,MAAM;OACd,MAAM;QACL,OAAOT,KAAK;;IAEhB,CAAC;IACD,OAAOY,IAAI,CAACC,SAAS,CAACjB,OAAO,EAAES,QAAQ,CAAC;EAC1C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}