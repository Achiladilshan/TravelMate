{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { html } from 'lit';\nimport { APILoader } from '../api_loader/api_loader.js';\nimport { extractTextAndURL } from './dom_utils.js';\nimport { isOpen } from './opening_hours.js';\n/**\n * Returns true if `place` is a `PlaceResult`, and false if it's a `Place`.\n *\n * @param place - A `google.maps.places.Place` or\n *     `google.maps.places.PlaceResult`.\n */\nexport function isPlaceResult(place) {\n  // To avoid depending on loading the API at runtime, we do not use\n  // `instanceof google.map.places.Place`.\n  // TODO: fix for property renaming safety?\n  return !place.hasOwnProperty('id');\n}\n/** Creates a new `WaypointInfo` object based on input data. */\nexport function makeWaypoint(data) {\n  if (isPlace(data)) {\n    return {\n      location: data.location?.toJSON() ?? undefined,\n      placeId: data.id,\n      query: data.formattedAddress ?? data.displayName ?? undefined\n    };\n  }\n  if (isLatLng(data)) {\n    return {\n      location: data.toJSON()\n    };\n  }\n  return {\n    location: data\n  };\n}\nfunction isPlace(data) {\n  return data.hasOwnProperty('id');\n}\nfunction isLatLng(data) {\n  return typeof data.lat === 'function';\n}\nconst PRICE_LEVEL_CONVERSIONS = Object.freeze({\n  'FREE': 0,\n  'INEXPENSIVE': 1,\n  'MODERATE': 2,\n  'EXPENSIVE': 3,\n  'VERY_EXPENSIVE': 4\n});\nconst REVERSE_PRICE_LEVEL_CONVERSIONS = Object.freeze(Object.fromEntries(Object.entries(PRICE_LEVEL_CONVERSIONS).map(tup => tup.reverse())));\n/**\n * Converts an enum price level to the corresponding numeric value. If passed a\n * numeric value, it will return it unchanged.\n */\nexport function priceLevelToNumeric(level) {\n  if (typeof level === 'number') return level;\n  return PRICE_LEVEL_CONVERSIONS[level] ?? null;\n}\n/**\n * Converts a numeric price level to the corresponding enum value. If passed an\n * enum value, it will return it unchanged.\n */\nexport function numericToPriceLevel(level) {\n  if (typeof level !== 'number') return level;\n  return REVERSE_PRICE_LEVEL_CONVERSIONS[level] ?? null;\n}\n/**\n * Renders attribution data returned by the Places API as either an `<a>` or a\n * `<span>` depending on the presence of the URL field.\n *\n * @param text Name of the author or provider.\n * @param url URL that links to the author or provider page.\n */\nexport function renderAttribution(text, url) {\n  return url ? html`<a href=${url} target=\"_blank\">${text}</a>` : html`<span>${text}</span>`;\n}\n/**\n * Creates a new `Place` object that sources its property values from\n * equivalent fields in the `PlaceResult` object, if they are defined.\n */\nexport async function makePlaceFromPlaceResult(placeResult, consumer) {\n  const placesLibrary = await APILoader.importLibrary('places', consumer);\n  const place = new placesLibrary.Place({\n    id: placeResult.place_id ?? 'PLACE_ID_MISSING'\n  });\n  let predefinedFields = convertToPlaceFields(placeResult);\n  // Override Place object's getters to return data from PlaceResult if defined.\n  return new Proxy(place, {\n    get(target, name, receiver) {\n      // Intercept calls to the `fetchFields()` method and filter out any field\n      // names in the request that already have values derived from PlaceResult.\n      if (name === 'fetchFields') {\n        return async request => {\n          const requestFields = request.fields;\n          const forwardedFields = requestFields.filter(field => predefinedFields[field] === undefined);\n          try {\n            return await target.fetchFields({\n              ...request,\n              fields: forwardedFields\n            });\n          } catch (e) {\n            // Place.fetchFields() is only available in beta versions of the\n            // Maps JS SDK. If a stable version of the SDK is loaded, fall\n            // back to the Place Details API.\n            if (isNotAvailableError(e, 'fetchFields()')) {\n              const placeResultFields = mapPlaceFieldsToPlaceResultFields(forwardedFields);\n              if (!placeResultFields.length) return {\n                place\n              };\n              const response = await fetchFromPlaceDetails(placesLibrary, place.id, placeResultFields);\n              predefinedFields = {\n                ...convertToPlaceFields(response),\n                ...predefinedFields\n              };\n              return {\n                place\n              };\n            }\n            throw e;\n          }\n        };\n      } else if (name === 'isOpen') {\n        return async d => {\n          try {\n            // Must redirect the original isOpen() method's `this` to point to\n            // the proxy object.\n            return await Reflect.get(target, name, receiver).apply(receiver, [d]);\n          } catch (e) {\n            if (isNotAvailableError(e, 'isOpen()')) return isOpen(receiver, d);\n            throw e;\n          }\n        };\n      }\n      const value = predefinedFields[name];\n      return value === undefined ? Reflect.get(target, name, receiver) : value;\n    }\n  });\n}\n/**\n * Determines whether the current Place object has enough data to evaluate\n * `isOpen()` or `getNextOpeningTime()` without making additional fetches.\n */\nexport function hasDataForOpeningCalculations(place) {\n  return !!(place.businessStatus && place.regularOpeningHours && place.utcOffsetMinutes != null);\n}\n/** Converts `PlaceResult` data to `Place`-compatible field values. */\nfunction convertToPlaceFields(placeResult) {\n  const place = {};\n  if (placeResult.address_components !== undefined) {\n    place.addressComponents = placeResult.address_components.map(component => ({\n      longText: component.long_name,\n      shortText: component.short_name,\n      types: component.types\n    }));\n  }\n  if (placeResult.adr_address !== undefined) {\n    place.adrFormatAddress = placeResult.adr_address;\n  }\n  if (placeResult.business_status !== undefined) {\n    place.businessStatus = placeResult.business_status;\n  }\n  if (placeResult.formatted_address !== undefined) {\n    place.formattedAddress = placeResult.formatted_address;\n  }\n  if (placeResult.formatted_phone_number !== undefined) {\n    place.nationalPhoneNumber = placeResult.formatted_phone_number;\n  }\n  if (placeResult.geometry !== undefined) {\n    const geometry = placeResult.geometry;\n    if (geometry.location) place.location = geometry.location;\n    if (geometry.viewport) place.viewport = geometry.viewport;\n  }\n  if (placeResult.html_attributions !== undefined) {\n    place.attributions = placeResult.html_attributions.map(html => {\n      const {\n        text,\n        url\n      } = extractTextAndURL(html);\n      return {\n        provider: text ?? '',\n        providerURI: url ?? null\n      };\n    });\n  }\n  if (placeResult.icon_background_color !== undefined) {\n    place.iconBackgroundColor = placeResult.icon_background_color;\n  }\n  if (placeResult.icon_mask_base_uri !== undefined) {\n    place.svgIconMaskURI = placeResult.icon_mask_base_uri;\n  }\n  if (placeResult.international_phone_number !== undefined) {\n    place.internationalPhoneNumber = placeResult.international_phone_number;\n  }\n  if (placeResult.name !== undefined) {\n    place.displayName = placeResult.name;\n  }\n  if (placeResult.opening_hours !== undefined) {\n    const periods = placeResult.opening_hours.periods?.map(period => ({\n      open: makeOpeningHoursPoint(period.open),\n      // A place that is open 24/7 does not return a close period.\n      close: period.close ? makeOpeningHoursPoint(period.close) : null\n    }));\n    place.regularOpeningHours = {\n      periods: periods ?? [],\n      weekdayDescriptions: placeResult.opening_hours.weekday_text ?? []\n    };\n  }\n  if (placeResult.photos !== undefined) {\n    place.photos = placeResult.photos.map(photo => {\n      const attributions = photo.html_attributions.map(html => {\n        const {\n          text,\n          url\n        } = extractTextAndURL(html);\n        return {\n          displayName: text ?? '',\n          photoURI: '',\n          uri: url || ''\n        };\n      });\n      return {\n        authorAttributions: attributions,\n        getURI: photo.getUrl,\n        heightPx: photo.height,\n        widthPx: photo.width\n      };\n    });\n  }\n  if (placeResult.place_id !== undefined) {\n    place.id = placeResult.place_id;\n  }\n  if (placeResult.plus_code !== undefined) {\n    place.plusCode = {\n      compoundCode: placeResult.plus_code.compound_code ?? null,\n      globalCode: placeResult.plus_code.global_code\n    };\n  }\n  if (placeResult.price_level !== undefined) {\n    place.priceLevel = numericToPriceLevel(placeResult.price_level);\n  }\n  if (placeResult.rating !== undefined) {\n    place.rating = placeResult.rating;\n  }\n  if (placeResult.reviews !== undefined) {\n    place.reviews = placeResult.reviews.map(review => ({\n      authorAttribution: {\n        displayName: review.author_name,\n        photoURI: review.profile_photo_url,\n        uri: review.author_url || ''\n      },\n      // Convert publish time from milliseconds to a Date object.\n      publishTime: new Date(review.time),\n      rating: review.rating ?? null,\n      relativePublishTimeDescription: review.relative_time_description,\n      text: review.text,\n      textLanguageCode: review.language\n    }));\n  }\n  if (placeResult.types !== undefined) {\n    place.types = placeResult.types;\n  }\n  if (placeResult.url !== undefined) {\n    place.googleMapsURI = placeResult.url;\n  }\n  if (placeResult.user_ratings_total !== undefined) {\n    place.userRatingCount = placeResult.user_ratings_total;\n  }\n  if (placeResult.utc_offset_minutes !== undefined) {\n    place.utcOffsetMinutes = placeResult.utc_offset_minutes;\n  }\n  if (placeResult.website !== undefined) {\n    place.websiteURI = placeResult.website;\n  }\n  return place;\n}\n/**\n * Creates a `OpeningHoursPoint` object, and extracts `hours` and `minutes`\n * from the `time` property.\n */\nfunction makeOpeningHoursPoint({\n  day,\n  hours,\n  minutes\n}) {\n  return {\n    day,\n    hour: hours,\n    minute: minutes\n  };\n}\nconst PLACE_TO_PLACE_RESULT_FIELDS = {\n  'addressComponents': 'address_components',\n  'adrFormatAddress': 'adr_address',\n  'businessStatus': 'business_status',\n  'formattedAddress': 'formatted_address',\n  'nationalPhoneNumber': 'formatted_phone_number',\n  'location': 'geometry',\n  'viewport': 'geometry',\n  'iconBackgroundColor': 'icon_background_color',\n  'svgIconMaskURI': 'icon_mask_base_uri',\n  'internationalPhoneNumber': 'international_phone_number',\n  'displayName': 'name',\n  'regularOpeningHours': 'opening_hours',\n  'photos': 'photos',\n  'plusCode': 'plus_code',\n  'priceLevel': 'price_level',\n  'rating': 'rating',\n  'reviews': 'reviews',\n  'types': 'types',\n  'googleMapsURI': 'url',\n  'userRatingCount': 'user_ratings_total',\n  'utcOffsetMinutes': 'utc_offset_minutes',\n  'websiteURI': 'website',\n  'id': 'place_id'\n};\n/** Maps a list of Place field names to equivalent PlaceResult field names. */\nexport function mapPlaceFieldsToPlaceResultFields(fields) {\n  const placeResultFields = [];\n  for (const placeField of fields) {\n    const mapped = PLACE_TO_PLACE_RESULT_FIELDS[placeField];\n    if (mapped) placeResultFields.push(mapped);\n  }\n  return placeResultFields;\n}\n/**\n * Determines if the error results from a specified property not being\n * available on the Place class (or an instance of that class).\n */\nexport function isNotAvailableError(e, property) {\n  if (!(e instanceof Error)) return false;\n  return e.message.startsWith(`Place.prototype.${property} is not available`) || e.message.startsWith(`google.maps.places.Place.${property} is not available`);\n}\nasync function fetchFromPlaceDetails(placesLibrary, placeId, fields) {\n  const placesService = new placesLibrary.PlacesService(document.createElement('div'));\n  return new Promise((resolve, reject) => {\n    placesService.getDetails({\n      placeId,\n      fields\n    }, (result, status) => {\n      if (result && status === 'OK') {\n        resolve(result);\n      } else {\n        reject(status);\n      }\n    });\n  });\n}","map":{"version":3,"names":["html","APILoader","extractTextAndURL","isOpen","isPlaceResult","place","hasOwnProperty","makeWaypoint","data","isPlace","location","toJSON","undefined","placeId","id","query","formattedAddress","displayName","isLatLng","lat","PRICE_LEVEL_CONVERSIONS","Object","freeze","REVERSE_PRICE_LEVEL_CONVERSIONS","fromEntries","entries","map","tup","reverse","priceLevelToNumeric","level","numericToPriceLevel","renderAttribution","text","url","makePlaceFromPlaceResult","placeResult","consumer","placesLibrary","importLibrary","Place","place_id","predefinedFields","convertToPlaceFields","Proxy","get","target","name","receiver","request","requestFields","fields","forwardedFields","filter","field","fetchFields","e","isNotAvailableError","placeResultFields","mapPlaceFieldsToPlaceResultFields","length","response","fetchFromPlaceDetails","d","Reflect","apply","value","hasDataForOpeningCalculations","businessStatus","regularOpeningHours","utcOffsetMinutes","address_components","addressComponents","component","longText","long_name","shortText","short_name","types","adr_address","adrFormatAddress","business_status","formatted_address","formatted_phone_number","nationalPhoneNumber","geometry","viewport","html_attributions","attributions","provider","providerURI","icon_background_color","iconBackgroundColor","icon_mask_base_uri","svgIconMaskURI","international_phone_number","internationalPhoneNumber","opening_hours","periods","period","open","makeOpeningHoursPoint","close","weekdayDescriptions","weekday_text","photos","photo","photoURI","uri","authorAttributions","getURI","getUrl","heightPx","height","widthPx","width","plus_code","plusCode","compoundCode","compound_code","globalCode","global_code","price_level","priceLevel","rating","reviews","review","authorAttribution","author_name","profile_photo_url","author_url","publishTime","Date","time","relativePublishTimeDescription","relative_time_description","textLanguageCode","language","googleMapsURI","user_ratings_total","userRatingCount","utc_offset_minutes","website","websiteURI","day","hours","minutes","hour","minute","PLACE_TO_PLACE_RESULT_FIELDS","placeField","mapped","push","property","Error","message","startsWith","placesService","PlacesService","document","createElement","Promise","resolve","reject","getDetails","result","status"],"sources":["/Users/achiladilshan/Desktop/travelmate/client/node_modules/@googlemaps/extended-component-library/src/utils/place_utils.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {html} from 'lit';\n\nimport {APILoader} from '../api_loader/api_loader.js';\n\nimport {extractTextAndURL} from './dom_utils.js';\nimport type {LatLng, LatLngLiteral, Place, PlaceResult, PriceLevel} from './googlemaps_types.js';\nimport {isOpen} from './opening_hours.js';\n\n/**\n * Returns true if `place` is a `PlaceResult`, and false if it's a `Place`.\n *\n * @param place - A `google.maps.places.Place` or\n *     `google.maps.places.PlaceResult`.\n */\nexport function isPlaceResult(place: Place|PlaceResult): place is PlaceResult {\n  // To avoid depending on loading the API at runtime, we do not use\n  // `instanceof google.map.places.Place`.\n  // TODO: fix for property renaming safety?\n  return !place.hasOwnProperty('id');\n}\n\n/**\n * Contains info that describes the origin or destination of a journey. This\n * interface is compatible with `google.maps.Place` and is suitable for use in\n * a request to the Directions or Distance Matrix services.\n */\nexport interface WaypointInfo {\n  location?: LatLngLiteral;\n  placeId?: string;\n  query?: string;\n}\n\n/** Creates a new `WaypointInfo` object based on input data. */\nexport function makeWaypoint(data: LatLng|LatLngLiteral|Place): WaypointInfo {\n  if (isPlace(data)) {\n    return {\n      location: data.location?.toJSON() ?? undefined,\n      placeId: data.id,\n      query: data.formattedAddress ?? data.displayName ?? undefined,\n    };\n  }\n  if (isLatLng(data)) {\n    return {location: data.toJSON()};\n  }\n  return {location: data};\n}\n\nfunction isPlace(data: LatLng|LatLngLiteral|Place): data is Place {\n  return data.hasOwnProperty('id');\n}\n\nfunction isLatLng(data: LatLng|LatLngLiteral): data is LatLng {\n  return typeof data.lat === 'function';\n}\n\nconst PRICE_LEVEL_CONVERSIONS: Record<PriceLevel, number> = Object.freeze({\n  'FREE': 0,\n  'INEXPENSIVE': 1,\n  'MODERATE': 2,\n  'EXPENSIVE': 3,\n  'VERY_EXPENSIVE': 4,\n});\n\nconst REVERSE_PRICE_LEVEL_CONVERSIONS: Record<number, PriceLevel> =\n    Object.freeze(Object.fromEntries(\n        Object.entries(PRICE_LEVEL_CONVERSIONS).map(tup => tup.reverse())));\n\n/**\n * Converts an enum price level to the corresponding numeric value. If passed a\n * numeric value, it will return it unchanged.\n */\nexport function priceLevelToNumeric(level: number|PriceLevel): number|null {\n  if (typeof level === 'number') return level;\n  return PRICE_LEVEL_CONVERSIONS[level] ?? null;\n}\n\n/**\n * Converts a numeric price level to the corresponding enum value. If passed an\n * enum value, it will return it unchanged.\n */\nexport function numericToPriceLevel(level: number|PriceLevel): PriceLevel|null {\n  if (typeof level !== 'number') return level;\n  return REVERSE_PRICE_LEVEL_CONVERSIONS[level] ?? null;\n}\n\n/**\n * Renders attribution data returned by the Places API as either an `<a>` or a\n * `<span>` depending on the presence of the URL field.\n *\n * @param text Name of the author or provider.\n * @param url URL that links to the author or provider page.\n */\nexport function renderAttribution(text: string, url: string|null) {\n  return url ? html`<a href=${url} target=\"_blank\">${text}</a>` :\n               html`<span>${text}</span>`;\n}\n\n/**\n * Creates a new `Place` object that sources its property values from\n * equivalent fields in the `PlaceResult` object, if they are defined.\n */\nexport async function makePlaceFromPlaceResult(\n    placeResult: PlaceResult, consumer?: HTMLElement): Promise<Place> {\n  const placesLibrary = await APILoader.importLibrary('places', consumer) as\n      typeof google.maps.places;\n  const place = new placesLibrary.Place(\n                    {id: placeResult.place_id ?? 'PLACE_ID_MISSING'}) as Place;\n  let predefinedFields = convertToPlaceFields(placeResult);\n\n  // Override Place object's getters to return data from PlaceResult if defined.\n  return new Proxy(place, {\n    get(target, name, receiver) {\n      // Intercept calls to the `fetchFields()` method and filter out any field\n      // names in the request that already have values derived from PlaceResult.\n      if (name === 'fetchFields') {\n        return async (request: google.maps.places.FetchFieldsRequest) => {\n          const requestFields = request.fields as [keyof Place];\n          const forwardedFields = requestFields.filter(\n              (field) => predefinedFields[field] === undefined);\n          try {\n            return await target.fetchFields(\n                {...request, fields: forwardedFields});\n          } catch (e: unknown) {\n            // Place.fetchFields() is only available in beta versions of the\n            // Maps JS SDK. If a stable version of the SDK is loaded, fall\n            // back to the Place Details API.\n            if (isNotAvailableError(e, 'fetchFields()')) {\n              const placeResultFields =\n                  mapPlaceFieldsToPlaceResultFields(forwardedFields);\n              if (!placeResultFields.length) return {place};\n              const response = await fetchFromPlaceDetails(\n                  placesLibrary, place.id, placeResultFields);\n              predefinedFields = {\n                ...convertToPlaceFields(response),\n                ...predefinedFields,\n              };\n              return {place};\n            }\n            throw e;\n          }\n        };\n      } else if (name === 'isOpen') {\n        return async (d?: Date) => {\n          try {\n            // Must redirect the original isOpen() method's `this` to point to\n            // the proxy object.\n            return await Reflect.get(target, name, receiver).apply(receiver, [\n              d\n            ]);\n          } catch (e: unknown) {\n            if (isNotAvailableError(e, 'isOpen()')) return isOpen(receiver, d);\n            throw e;\n          }\n        };\n      }\n      const value = predefinedFields[name as keyof Place];\n      return value === undefined ? Reflect.get(target, name, receiver) : value;\n    }\n  });\n}\n\n/**\n * Determines whether the current Place object has enough data to evaluate\n * `isOpen()` or `getNextOpeningTime()` without making additional fetches.\n */\nexport function hasDataForOpeningCalculations(place: Place): boolean {\n  return !!(\n      place.businessStatus && place.regularOpeningHours &&\n      (place.utcOffsetMinutes != null));\n}\n\n/** Converts `PlaceResult` data to `Place`-compatible field values. */\nfunction convertToPlaceFields(placeResult: PlaceResult): Partial<Place> {\n  const place: Partial<Place> = {};\n  if (placeResult.address_components !== undefined) {\n    place.addressComponents = placeResult.address_components.map(\n        (component: google.maps.GeocoderAddressComponent) => ({\n          longText: component.long_name,\n          shortText: component.short_name,\n          types: component.types,\n        }));\n  }\n  if (placeResult.adr_address !== undefined) {\n    place.adrFormatAddress = placeResult.adr_address;\n  }\n  if (placeResult.business_status !== undefined) {\n    place.businessStatus = placeResult.business_status;\n  }\n  if (placeResult.formatted_address !== undefined) {\n    place.formattedAddress = placeResult.formatted_address;\n  }\n  if (placeResult.formatted_phone_number !== undefined) {\n    place.nationalPhoneNumber = placeResult.formatted_phone_number;\n  }\n  if (placeResult.geometry !== undefined) {\n    const geometry = placeResult.geometry;\n    if (geometry.location) place.location = geometry.location;\n    if (geometry.viewport) place.viewport = geometry.viewport;\n  }\n  if (placeResult.html_attributions !== undefined) {\n    place.attributions = placeResult.html_attributions.map((html: string) => {\n      const {text, url} = extractTextAndURL(html);\n      return {provider: text ?? '', providerURI: url ?? null};\n    });\n  }\n  if (placeResult.icon_background_color !== undefined) {\n    place.iconBackgroundColor = placeResult.icon_background_color;\n  }\n  if (placeResult.icon_mask_base_uri !== undefined) {\n    place.svgIconMaskURI = placeResult.icon_mask_base_uri;\n  }\n  if (placeResult.international_phone_number !== undefined) {\n    place.internationalPhoneNumber = placeResult.international_phone_number;\n  }\n  if (placeResult.name !== undefined) {\n    place.displayName = placeResult.name;\n  }\n  if (placeResult.opening_hours !== undefined) {\n    const periods = placeResult.opening_hours.periods?.map(\n        (period: google.maps.places.PlaceOpeningHoursPeriod) => ({\n          open: makeOpeningHoursPoint(period.open),\n          // A place that is open 24/7 does not return a close period.\n          close: period.close ? makeOpeningHoursPoint(period.close) : null,\n        }));\n    place.regularOpeningHours = {\n      periods: periods ?? [],\n      weekdayDescriptions: placeResult.opening_hours.weekday_text ?? [],\n    };\n  }\n  if (placeResult.photos !== undefined) {\n    place.photos =\n        placeResult.photos.map((photo: google.maps.places.PlacePhoto) => {\n          const attributions = photo.html_attributions.map((html) => {\n            const {text, url} = extractTextAndURL(html);\n            return {displayName: text ?? '', photoURI: '', uri: url || ''};\n          });\n          return {\n            authorAttributions: attributions,\n            getURI: photo.getUrl,\n            heightPx: photo.height,\n            widthPx: photo.width,\n          };\n        });\n  }\n  if (placeResult.place_id !== undefined) {\n    place.id = placeResult.place_id;\n  }\n  if (placeResult.plus_code !== undefined) {\n    place.plusCode = {\n      compoundCode: placeResult.plus_code.compound_code ?? null,\n      globalCode: placeResult.plus_code.global_code,\n    };\n  }\n  if (placeResult.price_level !== undefined) {\n    place.priceLevel = numericToPriceLevel(placeResult.price_level);\n  }\n  if (placeResult.rating !== undefined) {\n    place.rating = placeResult.rating;\n  }\n  if (placeResult.reviews !== undefined) {\n    place.reviews = placeResult.reviews.map(\n        (review: google.maps.places.PlaceReview) => ({\n          authorAttribution: {\n            displayName: review.author_name,\n            photoURI: review.profile_photo_url,\n            uri: review.author_url || '',\n          },\n          // Convert publish time from milliseconds to a Date object.\n          publishTime: new Date(review.time),\n          rating: review.rating ?? null,\n          relativePublishTimeDescription: review.relative_time_description,\n          text: review.text,\n          textLanguageCode: review.language,\n        }));\n  }\n  if (placeResult.types !== undefined) {\n    place.types = placeResult.types;\n  }\n  if (placeResult.url !== undefined) {\n    place.googleMapsURI = placeResult.url;\n  }\n  if (placeResult.user_ratings_total !== undefined) {\n    place.userRatingCount = placeResult.user_ratings_total;\n  }\n  if (placeResult.utc_offset_minutes !== undefined) {\n    place.utcOffsetMinutes = placeResult.utc_offset_minutes;\n  }\n  if (placeResult.website !== undefined) {\n    place.websiteURI = placeResult.website;\n  }\n  return place;\n}\n\n/**\n * Creates a `OpeningHoursPoint` object, and extracts `hours` and `minutes`\n * from the `time` property.\n */\nfunction makeOpeningHoursPoint(\n    {day, hours, minutes}: google.maps.places.PlaceOpeningHoursTime):\n    google.maps.places.OpeningHoursPoint {\n  return {day, hour: hours, minute: minutes};\n}\n\nconst PLACE_TO_PLACE_RESULT_FIELDS:\n    Partial<Record<keyof Place, keyof PlaceResult>> = {\n      'addressComponents': 'address_components',\n      'adrFormatAddress': 'adr_address',\n      'businessStatus': 'business_status',\n      'formattedAddress': 'formatted_address',\n      'nationalPhoneNumber': 'formatted_phone_number',\n      'location': 'geometry',\n      'viewport': 'geometry',\n      'iconBackgroundColor': 'icon_background_color',\n      'svgIconMaskURI': 'icon_mask_base_uri',\n      'internationalPhoneNumber': 'international_phone_number',\n      'displayName': 'name',\n      'regularOpeningHours': 'opening_hours',\n      'photos': 'photos',\n      'plusCode': 'plus_code',\n      'priceLevel': 'price_level',\n      'rating': 'rating',\n      'reviews': 'reviews',\n      'types': 'types',\n      'googleMapsURI': 'url',\n      'userRatingCount': 'user_ratings_total',\n      'utcOffsetMinutes': 'utc_offset_minutes',\n      'websiteURI': 'website',\n      'id': 'place_id'\n    };\n\n/** Maps a list of Place field names to equivalent PlaceResult field names. */\nexport function mapPlaceFieldsToPlaceResultFields(fields: Array<keyof Place>):\n    Array<keyof PlaceResult> {\n  const placeResultFields: Array<keyof PlaceResult> = [];\n  for (const placeField of fields) {\n    const mapped = PLACE_TO_PLACE_RESULT_FIELDS[placeField];\n    if (mapped) placeResultFields.push(mapped);\n  }\n  return placeResultFields;\n}\n\n/**\n * Determines if the error results from a specified property not being\n * available on the Place class (or an instance of that class).\n */\nexport function isNotAvailableError(e: unknown, property: string): e is Error {\n  if (!(e instanceof Error)) return false;\n  return e.message.startsWith(`Place.prototype.${property} is not available`) ||\n      e.message.startsWith(\n          `google.maps.places.Place.${property} is not available`);\n}\n\nasync function fetchFromPlaceDetails(\n    placesLibrary: typeof google.maps.places, placeId: string,\n    fields: string[]): Promise<PlaceResult> {\n  const placesService =\n      new placesLibrary.PlacesService(document.createElement('div'));\n  return new Promise((resolve, reject) => {\n    placesService.getDetails({placeId, fields}, (result, status) => {\n      if (result && status === 'OK') {\n        resolve(result);\n      } else {\n        reject(status);\n      }\n    });\n  });\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}