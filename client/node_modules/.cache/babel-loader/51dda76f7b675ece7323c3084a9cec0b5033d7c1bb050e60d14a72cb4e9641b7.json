{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate, __metadata } from \"tslib\";\nimport { css, html } from 'lit';\nimport { customElement, query, queryAssignedElements, state } from 'lit/decorators.js';\nimport { styleMap } from 'lit/directives/style-map.js';\nimport { BaseComponent } from '../base/base_component.js';\nimport { SlotValidationController } from '../base/slot_validation_controller.js';\nimport { getDeepActiveElement, someDeepContains } from '../utils/deep_element_access.js';\n/**\n * The overlay layout component allows you to display information in a\n * responsive panel view that sits on top of main content, like a map or a list.\n * You might use this to show a modal dialog, more details about a place, or\n * settings.\n *\n * This component helps manage keyboard focus when opening and closing the\n * overlay.\n *\n * The size of the gmpx-overlay-layout can be set directly with the `width` and\n * `height` properties. If none are provided, it will fill the size of its\n * containing element.\n *\n * ![](./doc_src/overlay-layout.gif)\n *\n * **To use this component, you'll need to specify `slot=\"main\"` or\n * `slot=\"overlay\"` on its children.** Read more on using slots\n * [here](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_templates_and_slots#adding_flexibility_with_slots).\n *\n * @slot main - Main content, displayed by default.\n * @slot overlay - Overlay content that replaces the main content when the panel\n * is opened.\n */\nlet OverlayLayout = class OverlayLayout extends BaseComponent {\n  constructor() {\n    super(...arguments);\n    this.opened = false;\n    this.mainLastActiveEl = null;\n    this.slotValidator = new SlotValidationController(this, this.logger, ['main', 'overlay']);\n  }\n  /**\n   * Opens the overlay panel.\n   *\n   * If focus is currently in the main content, the focused element will be\n   * saved to regain focus when closing the overlay. Focus will then move to\n   * the element in the overlay slot with autofocus, if present. If no element\n   * has autofocus, the internal overlay container will be focused so that\n   * pressing Tab will focus the first interactive element in the overlay slot.\n   *\n   * Overlay content will be scrolled to the top, if the panel was previously\n   * opened and scrolled down.\n   */\n  async showOverlay() {\n    if (this.opened) return;\n    this.mainLastActiveEl = this.getMainActiveEl();\n    this.opened = true;\n    await this.updateComplete;\n    this.overlayContainer.scroll(0, 0);\n    if (this.mainLastActiveEl) {\n      const autofocusEl = this.getOverlayAutofocusEl();\n      if (autofocusEl) {\n        autofocusEl.focus();\n      } else {\n        this.overlayContainer.focus();\n      }\n    }\n  }\n  /**\n   * Closes the overlay panel.\n   *\n   * If focus is currently in the overlay content, focus will move to the last\n   * focused main element, if this was saved when opening the panel. If no\n   * focused element was saved, the internal main container will be focused\n   * so that pressing Tab will focus the first interactive element in the main\n   * slot.\n   */\n  async hideOverlay() {\n    if (!this.opened) return;\n    const overlayActiveEl = this.getOverlayActiveEl();\n    this.opened = false;\n    if (overlayActiveEl || getDeepActiveElement() === this.overlayContainer) {\n      await this.updateComplete;\n      if (this.mainLastActiveEl) {\n        this.mainLastActiveEl.focus();\n      } else {\n        this.mainContainer.focus();\n      }\n    }\n    this.mainLastActiveEl = null;\n  }\n  render() {\n    // clang-format off\n    return html`\n      <div class=\"outer-container\">\n        <div\n          class=\"inner-container main-container\"\n          style=${styleMap({\n      'display': this.opened ? 'none' : 'block'\n    })}\n          tabindex=\"-1\"\n        >\n          <slot name=\"main\"></slot>\n        </div>\n        <div\n          class=\"inner-container overlay-container\"\n          style=${styleMap({\n      'display': this.opened ? 'block' : 'none'\n    })}\n          tabindex=\"-1\"\n          @keydown=${this.handleOverlayKeydown}\n        >\n          <slot name=\"overlay\"></slot>\n        </div>\n      </div>\n    `;\n    // clang-format on\n  }\n  handleOverlayKeydown(e) {\n    if (e.key === 'Escape') {\n      this.hideOverlay();\n    }\n  }\n  /**\n   * Returns the active element if it's a descendant, even across shadow\n   * boundaries, of one of the elements in els.\n   */\n  getContainedActiveEl(els) {\n    const deepActiveEl = getDeepActiveElement();\n    if (deepActiveEl instanceof HTMLElement) {\n      if (someDeepContains(els, deepActiveEl)) return deepActiveEl;\n    }\n    return null;\n  }\n  getMainActiveEl() {\n    return this.getContainedActiveEl(this.mainAssignedEls);\n  }\n  getOverlayActiveEl() {\n    return this.getContainedActiveEl(this.overlayAssignedEls);\n  }\n  getOverlayAutofocusEl() {\n    for (const el of this.overlayAssignedEls) {\n      const autofocusEl = el.querySelector('[autofocus]');\n      if (autofocusEl && autofocusEl instanceof HTMLElement) {\n        return autofocusEl;\n      }\n    }\n    return null;\n  }\n};\nOverlayLayout.styles = css`\n    :host(:not([hidden])) {\n      display: block;\n      height: 100%;\n    }\n    .outer-container {\n      display: block;\n      height: 100%;\n      position: relative;\n    }\n    .inner-container {\n      inset: 0;\n      overflow: auto;\n      position: absolute;\n    }\n    .inner-container:focus-visible {\n      outline: none;\n    }\n  `;\n__decorate([queryAssignedElements({\n  slot: 'main'\n}), __metadata(\"design:type\", Array)], OverlayLayout.prototype, \"mainAssignedEls\", void 0);\n__decorate([queryAssignedElements({\n  slot: 'overlay'\n}), __metadata(\"design:type\", Array)], OverlayLayout.prototype, \"overlayAssignedEls\", void 0);\n__decorate([query('.main-container'), __metadata(\"design:type\", HTMLDivElement)], OverlayLayout.prototype, \"mainContainer\", void 0);\n__decorate([query('.overlay-container'), __metadata(\"design:type\", HTMLDivElement)], OverlayLayout.prototype, \"overlayContainer\", void 0);\n__decorate([state(), __metadata(\"design:type\", Object)], OverlayLayout.prototype, \"opened\", void 0);\nOverlayLayout = __decorate([customElement('gmpx-overlay-layout')], OverlayLayout);\nexport { OverlayLayout };","map":{"version":3,"names":["css","html","customElement","query","queryAssignedElements","state","styleMap","BaseComponent","SlotValidationController","getDeepActiveElement","someDeepContains","OverlayLayout","constructor","opened","mainLastActiveEl","slotValidator","logger","showOverlay","getMainActiveEl","updateComplete","overlayContainer","scroll","autofocusEl","getOverlayAutofocusEl","focus","hideOverlay","overlayActiveEl","getOverlayActiveEl","mainContainer","render","handleOverlayKeydown","e","key","getContainedActiveEl","els","deepActiveEl","HTMLElement","mainAssignedEls","overlayAssignedEls","el","querySelector","styles","__decorate","slot","HTMLDivElement"],"sources":["/Users/achiladilshan/Desktop/travelmate/client/node_modules/@googlemaps/extended-component-library/src/overlay_layout/overlay_layout.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {css, CSSResultGroup, html} from 'lit';\nimport {customElement, query, queryAssignedElements, state} from 'lit/decorators.js';\nimport {styleMap} from 'lit/directives/style-map.js';\n\nimport {BaseComponent} from '../base/base_component.js';\nimport {SlotValidationController} from '../base/slot_validation_controller.js';\nimport {getDeepActiveElement, someDeepContains} from '../utils/deep_element_access.js';\n\n/**\n * The overlay layout component allows you to display information in a\n * responsive panel view that sits on top of main content, like a map or a list.\n * You might use this to show a modal dialog, more details about a place, or\n * settings.\n *\n * This component helps manage keyboard focus when opening and closing the\n * overlay.\n *\n * The size of the gmpx-overlay-layout can be set directly with the `width` and\n * `height` properties. If none are provided, it will fill the size of its\n * containing element.\n *\n * ![](./doc_src/overlay-layout.gif)\n *\n * **To use this component, you'll need to specify `slot=\"main\"` or\n * `slot=\"overlay\"` on its children.** Read more on using slots\n * [here](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_templates_and_slots#adding_flexibility_with_slots).\n *\n * @slot main - Main content, displayed by default.\n * @slot overlay - Overlay content that replaces the main content when the panel\n * is opened.\n */\n@customElement('gmpx-overlay-layout')\nexport class OverlayLayout extends BaseComponent {\n  static override styles: CSSResultGroup = css`\n    :host(:not([hidden])) {\n      display: block;\n      height: 100%;\n    }\n    .outer-container {\n      display: block;\n      height: 100%;\n      position: relative;\n    }\n    .inner-container {\n      inset: 0;\n      overflow: auto;\n      position: absolute;\n    }\n    .inner-container:focus-visible {\n      outline: none;\n    }\n  `;\n\n  @queryAssignedElements({slot: 'main'})\n  private readonly mainAssignedEls!: HTMLElement[];\n\n  @queryAssignedElements({slot: 'overlay'})\n  private readonly overlayAssignedEls!: HTMLElement[];\n\n  @query('.main-container') private readonly mainContainer!: HTMLDivElement;\n\n  @query('.overlay-container')\n  private readonly overlayContainer!: HTMLDivElement;\n\n  @state() private opened = false;\n  private mainLastActiveEl: HTMLElement|null = null;\n\n  protected slotValidator =\n      new SlotValidationController(this, this.logger, ['main', 'overlay']);\n\n  /**\n   * Opens the overlay panel.\n   *\n   * If focus is currently in the main content, the focused element will be\n   * saved to regain focus when closing the overlay. Focus will then move to\n   * the element in the overlay slot with autofocus, if present. If no element\n   * has autofocus, the internal overlay container will be focused so that\n   * pressing Tab will focus the first interactive element in the overlay slot.\n   *\n   * Overlay content will be scrolled to the top, if the panel was previously\n   * opened and scrolled down.\n   */\n  async showOverlay() {\n    if (this.opened) return;\n    this.mainLastActiveEl = this.getMainActiveEl();\n    this.opened = true;\n    await this.updateComplete;\n    this.overlayContainer.scroll(0, 0);\n    if (this.mainLastActiveEl) {\n      const autofocusEl = this.getOverlayAutofocusEl();\n      if (autofocusEl) {\n        autofocusEl.focus();\n      } else {\n        this.overlayContainer.focus();\n      }\n    }\n  }\n\n  /**\n   * Closes the overlay panel.\n   *\n   * If focus is currently in the overlay content, focus will move to the last\n   * focused main element, if this was saved when opening the panel. If no\n   * focused element was saved, the internal main container will be focused\n   * so that pressing Tab will focus the first interactive element in the main\n   * slot.\n   */\n  async hideOverlay() {\n    if (!this.opened) return;\n    const overlayActiveEl = this.getOverlayActiveEl();\n    this.opened = false;\n    if (overlayActiveEl || (getDeepActiveElement() === this.overlayContainer)) {\n      await this.updateComplete;\n      if (this.mainLastActiveEl) {\n        this.mainLastActiveEl.focus();\n      } else {\n        this.mainContainer.focus();\n      }\n    }\n    this.mainLastActiveEl = null;\n  }\n\n  protected override render() {\n    // clang-format off\n    return html`\n      <div class=\"outer-container\">\n        <div\n          class=\"inner-container main-container\"\n          style=${styleMap({'display': this.opened ? 'none' : 'block'})}\n          tabindex=\"-1\"\n        >\n          <slot name=\"main\"></slot>\n        </div>\n        <div\n          class=\"inner-container overlay-container\"\n          style=${styleMap({'display': this.opened ? 'block' : 'none'})}\n          tabindex=\"-1\"\n          @keydown=${this.handleOverlayKeydown}\n        >\n          <slot name=\"overlay\"></slot>\n        </div>\n      </div>\n    `;\n    // clang-format on\n  }\n\n  private handleOverlayKeydown(e: KeyboardEvent) {\n    if (e.key === 'Escape') {\n      this.hideOverlay();\n    }\n  }\n\n  /**\n   * Returns the active element if it's a descendant, even across shadow\n   * boundaries, of one of the elements in els.\n   */\n  private getContainedActiveEl(els: Element[]): HTMLElement|null {\n    const deepActiveEl = getDeepActiveElement();\n    if (deepActiveEl instanceof HTMLElement) {\n      if (someDeepContains(els, deepActiveEl)) return deepActiveEl;\n    }\n    return null;\n  }\n\n  private getMainActiveEl(): HTMLElement|null {\n    return this.getContainedActiveEl(this.mainAssignedEls);\n  }\n\n  private getOverlayActiveEl(): HTMLElement|null {\n    return this.getContainedActiveEl(this.overlayAssignedEls);\n  }\n\n  private getOverlayAutofocusEl(): HTMLElement|null {\n    for (const el of this.overlayAssignedEls) {\n      const autofocusEl = el.querySelector('[autofocus]');\n      if (autofocusEl && autofocusEl instanceof HTMLElement) {\n        return autofocusEl;\n      }\n    }\n    return null;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'gmpx-overlay-layout': OverlayLayout;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}