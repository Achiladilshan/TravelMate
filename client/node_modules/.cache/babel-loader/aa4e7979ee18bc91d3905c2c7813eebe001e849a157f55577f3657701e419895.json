{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { APILoader } from '../../api_loader/api_loader.js';\nimport { LRUMap } from '../../utils/lru_map.js';\n/**\n * Makes a promise that will resolve to a new `Place` with the given ID, or\n * reject with an error if the `Place` constructor throws one. This must be done\n * asynchronously due to the loading of the `Place` constructor from the API.\n */\nasync function makeNewPlacePromise(id, consumer) {\n  const {\n    Place\n  } = await APILoader.importLibrary('places', consumer);\n  return new Place({\n    id\n  });\n}\n/**\n * A limited-capacity cache of `Place` objects keyed by place ID. Creates new\n * `Place` objects as needed when they do not exist already.\n */\nexport class CachedPlaceLookup {\n  /**\n   * @param capacity - The maximum number of `Place` objects to keep in the\n   *     cache.\n   * @param consumer - Optionally specify the custom element using the cached\n   *     place lookup, to provide more helpful console warnings when the places\n   *     library cannot be loaded.\n   */\n  constructor(capacity, consumer) {\n    this.consumer = consumer;\n    this.cache = new LRUMap(capacity);\n  }\n  /**\n   * Gets the cached `Place` with the given ID. If none exists, a new `Place`\n   * will be created, cached, and returned.\n   *\n   * Note: The returned promise will be rejected with an error from the `Place`\n   * constructor if `id` is an empty string.\n   */\n  getPlace(id) {\n    const cachedPlacePromise = this.cache.get(id);\n    if (cachedPlacePromise) return cachedPlacePromise;\n    const newPlacePromise = makeNewPlacePromise(id, this.consumer);\n    this.cache.set(id, newPlacePromise);\n    return newPlacePromise;\n  }\n  /**\n   * Adds the provided `Place` to the cache, replacing the existing `Place` if\n   * one exists already.\n   */\n  updatePlace(place) {\n    this.cache.set(place.id, Promise.resolve(place));\n  }\n}","map":{"version":3,"names":["APILoader","LRUMap","makeNewPlacePromise","id","consumer","Place","importLibrary","CachedPlaceLookup","constructor","capacity","cache","getPlace","cachedPlacePromise","get","newPlacePromise","set","updatePlace","place","Promise","resolve"],"sources":["/Users/achiladilshan/Desktop/travelmate/client/node_modules/@googlemaps/extended-component-library/src/place_building_blocks/place_data_provider/cached_place_lookup.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {APILoader} from '../../api_loader/api_loader.js';\nimport type {Place} from '../../utils/googlemaps_types.js';\nimport {LRUMap} from '../../utils/lru_map.js';\n\n\n/**\n * Makes a promise that will resolve to a new `Place` with the given ID, or\n * reject with an error if the `Place` constructor throws one. This must be done\n * asynchronously due to the loading of the `Place` constructor from the API.\n */\nasync function makeNewPlacePromise(\n    id: string, consumer?: HTMLElement): Promise<Place> {\n  const {Place} = await APILoader.importLibrary('places', consumer) as\n      typeof google.maps.places;\n  return new Place({id}) as Place;\n}\n\n/**\n * A limited-capacity cache of `Place` objects keyed by place ID. Creates new\n * `Place` objects as needed when they do not exist already.\n */\nexport class CachedPlaceLookup {\n  private readonly cache: LRUMap<string, Promise<Place>>;\n\n  /**\n   * @param capacity - The maximum number of `Place` objects to keep in the\n   *     cache.\n   * @param consumer - Optionally specify the custom element using the cached\n   *     place lookup, to provide more helpful console warnings when the places\n   *     library cannot be loaded.\n   */\n  constructor(capacity: number, private readonly consumer?: HTMLElement) {\n    this.cache = new LRUMap(capacity);\n  }\n\n  /**\n   * Gets the cached `Place` with the given ID. If none exists, a new `Place`\n   * will be created, cached, and returned.\n   *\n   * Note: The returned promise will be rejected with an error from the `Place`\n   * constructor if `id` is an empty string.\n   */\n  getPlace(id: string): Promise<Place> {\n    const cachedPlacePromise = this.cache.get(id);\n    if (cachedPlacePromise) return cachedPlacePromise;\n\n    const newPlacePromise = makeNewPlacePromise(id, this.consumer);\n    this.cache.set(id, newPlacePromise);\n    return newPlacePromise;\n  }\n\n  /**\n   * Adds the provided `Place` to the cache, replacing the existing `Place` if\n   * one exists already.\n   */\n  updatePlace(place: Place) {\n    this.cache.set(place.id, Promise.resolve(place));\n  }\n}\n"],"mappings":"AAAA;;;;;AAMA,SAAQA,SAAS,QAAO,gCAAgC;AAExD,SAAQC,MAAM,QAAO,wBAAwB;AAG7C;;;;;AAKA,eAAeC,mBAAmBA,CAC9BC,EAAU,EAAEC,QAAsB;EACpC,MAAM;IAACC;EAAK,CAAC,GAAG,MAAML,SAAS,CAACM,aAAa,CAAC,QAAQ,EAAEF,QAAQ,CACnC;EAC7B,OAAO,IAAIC,KAAK,CAAC;IAACF;EAAE,CAAC,CAAU;AACjC;AAEA;;;;AAIA,OAAM,MAAOI,iBAAiB;EAG5B;;;;;;;EAOAC,YAAYC,QAAgB,EAAmBL,QAAsB;IAAtB,KAAAA,QAAQ,GAARA,QAAQ;IACrD,IAAI,CAACM,KAAK,GAAG,IAAIT,MAAM,CAACQ,QAAQ,CAAC;EACnC;EAEA;;;;;;;EAOAE,QAAQA,CAACR,EAAU;IACjB,MAAMS,kBAAkB,GAAG,IAAI,CAACF,KAAK,CAACG,GAAG,CAACV,EAAE,CAAC;IAC7C,IAAIS,kBAAkB,EAAE,OAAOA,kBAAkB;IAEjD,MAAME,eAAe,GAAGZ,mBAAmB,CAACC,EAAE,EAAE,IAAI,CAACC,QAAQ,CAAC;IAC9D,IAAI,CAACM,KAAK,CAACK,GAAG,CAACZ,EAAE,EAAEW,eAAe,CAAC;IACnC,OAAOA,eAAe;EACxB;EAEA;;;;EAIAE,WAAWA,CAACC,KAAY;IACtB,IAAI,CAACP,KAAK,CAACK,GAAG,CAACE,KAAK,CAACd,EAAE,EAAEe,OAAO,CAACC,OAAO,CAACF,KAAK,CAAC,CAAC;EAClD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}